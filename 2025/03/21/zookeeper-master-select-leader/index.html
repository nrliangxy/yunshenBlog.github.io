<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>spark在standalone模式下，使用zookeeper进行master选举流程剖析 | 只在此山中，云深不知处</title><meta name="author" content="nrliangxy"><meta name="copyright" content="nrliangxy"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="&emsp;&emsp; 背景 spark集群在standalone模式下，为了确保master的高可用性，使用zookeeper来实现对master监控和选举 如果当前leader宕机后，如何实现leader的快速选举和相关worker节点，driver节点的快速恢复 本文要详细探讨一下leader选举和恢复的详细细节  流程梳理1.首次启动spark集群的master节点，使用start-ma">
<meta property="og:type" content="article">
<meta property="og:title" content="spark在standalone模式下，使用zookeeper进行master选举流程剖析">
<meta property="og:url" content="https://nrliangxy.github.io/yunshenBlog.github.io/2025/03/21/zookeeper-master-select-leader/index.html">
<meta property="og:site_name" content="只在此山中，云深不知处">
<meta property="og:description" content="&emsp;&emsp; 背景 spark集群在standalone模式下，为了确保master的高可用性，使用zookeeper来实现对master监控和选举 如果当前leader宕机后，如何实现leader的快速选举和相关worker节点，driver节点的快速恢复 本文要详细探讨一下leader选举和恢复的详细细节  流程梳理1.首次启动spark集群的master节点，使用start-ma">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://nrliangxy.github.io/yunshenBlog.github.io/img/butterfly-icon.png">
<meta property="article:published_time" content="2025-03-21T03:57:09.000Z">
<meta property="article:modified_time" content="2025-03-21T05:07:54.137Z">
<meta property="article:author" content="nrliangxy">
<meta property="article:tag" content="spark 3.3.0">
<meta property="article:tag" content="standalone">
<meta property="article:tag" content="rpc">
<meta property="article:tag" content="master">
<meta property="article:tag" content="zookeeper">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://nrliangxy.github.io/yunshenBlog.github.io/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "spark在standalone模式下，使用zookeeper进行master选举流程剖析",
  "url": "https://nrliangxy.github.io/yunshenBlog.github.io/2025/03/21/zookeeper-master-select-leader/",
  "image": "https://nrliangxy.github.io/yunshenBlog.github.io/img/butterfly-icon.png",
  "datePublished": "2025-03-21T03:57:09.000Z",
  "dateModified": "2025-03-21T05:07:54.137Z",
  "author": [
    {
      "@type": "Person",
      "name": "nrliangxy",
      "url": "https://nrliangxy.github.io/yunshenBlog.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/yunshenBlog.github.io/img/favicon.png"><link rel="canonical" href="https://nrliangxy.github.io/yunshenBlog.github.io/2025/03/21/zookeeper-master-select-leader/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/yunshenBlog.github.io/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/yunshenBlog.github.io/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'spark在standalone模式下，使用zookeeper进行master选举流程剖析',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/yunshenBlog.github.io/"><span class="site-name">只在此山中，云深不知处</span></a><a class="nav-page-title" href="/yunshenBlog.github.io/"><span class="site-name">spark在standalone模式下，使用zookeeper进行master选举流程剖析</span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">spark在standalone模式下，使用zookeeper进行master选举流程剖析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2025-03-21T03:57:09.000Z" title="Created 2025-03-21 11:57:09">2025-03-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-03-21T05:07:54.137Z" title="Updated 2025-03-21 13:07:54">2025-03-21</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/yunshenBlog.github.io/categories/%E6%8A%80%E6%9C%AF/">技术</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/yunshenBlog.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%A4%A7%E6%95%B0%E6%8D%AE%E8%AE%A1%E7%AE%97/">大数据计算</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/yunshenBlog.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%A4%A7%E6%95%B0%E6%8D%AE%E8%AE%A1%E7%AE%97/%E6%89%B9%E5%A4%84%E7%90%86/">批处理</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/yunshenBlog.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%A4%A7%E6%95%B0%E6%8D%AE%E8%AE%A1%E7%AE%97/%E6%89%B9%E5%A4%84%E7%90%86/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>&emsp;&emsp;</p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><ul>
<li>spark集群在standalone模式下，为了确保master的高可用性，使用zookeeper来实现对master监控和选举</li>
<li>如果当前leader宕机后，如何实现leader的快速选举和相关worker节点，driver节点的快速恢复</li>
<li>本文要详细探讨一下leader选举和恢复的详细细节</li>
</ul>
<h2 id="流程梳理"><a href="#流程梳理" class="headerlink" title="流程梳理"></a>流程梳理</h2><h3 id="1-首次启动spark集群的master节点，使用start-master-sh来启动master节点"><a href="#1-首次启动spark集群的master节点，使用start-master-sh来启动master节点" class="headerlink" title="1.首次启动spark集群的master节点，使用start-master.sh来启动master节点"></a>1.首次启动spark集群的master节点，使用start-master.sh来启动master节点</h3><h4 id="1-代码"><a href="#1-代码" class="headerlink" title="(1) 代码"></a>(1) 代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">private[deploy] object Master extends Logging &#123;</span><br><span class="line">  val SYSTEM_NAME = &quot;sparkMaster&quot;</span><br><span class="line">  val ENDPOINT_NAME = &quot;Master&quot;</span><br><span class="line"></span><br><span class="line">  def main(argStrings: Array[String]): Unit = &#123;</span><br><span class="line">    Thread.setDefaultUncaughtExceptionHandler(new SparkUncaughtExceptionHandler(</span><br><span class="line">      exitOnUncaughtException = false))</span><br><span class="line">    Utils.initDaemon(log)</span><br><span class="line">    val conf = new SparkConf</span><br><span class="line">    val args = new MasterArguments(argStrings, conf)</span><br><span class="line">    val (rpcEnv, _, _) = startRpcEnvAndEndpoint(args.host, args.port, args.webUiPort, conf)</span><br><span class="line">    rpcEnv.awaitTermination()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Start the Master and return a three tuple of:</span><br><span class="line">   *   (1) The Master RpcEnv</span><br><span class="line">   *   (2) The web UI bound port</span><br><span class="line">   *   (3) The REST server bound port, if any</span><br><span class="line">   *</span><br><span class="line">   *  初始化安全组件：基于配置创建 SecurityManager。</span><br><span class="line">   *</span><br><span class="line">   *  启动 RPC 服务：创建 RpcEnv，绑定到指定地址和端口。</span><br><span class="line">   *</span><br><span class="line">   *  注册 Master 端点：将 Master 实例注册为 RPC 端点，处理集群管理逻辑。</span><br><span class="line">   *</span><br><span class="line">   *  动态端口分配：若端口参数为 0，通过 RPC 请求获取实际绑定的端口。</span><br><span class="line">   *</span><br><span class="line">   *  返回关键信息：将 RPC 环境、Web UI 端口和 REST 端口返回给调用者。</span><br><span class="line">   */</span><br><span class="line">  def startRpcEnvAndEndpoint(</span><br><span class="line">      host: String,</span><br><span class="line">      port: Int,</span><br><span class="line">      webUiPort: Int,</span><br><span class="line">      conf: SparkConf): (RpcEnv, Int, Option[Int]) = &#123;</span><br><span class="line">    val securityMgr = new SecurityManager(conf)</span><br><span class="line">    val rpcEnv = RpcEnv.create(SYSTEM_NAME, host, port, conf, securityMgr)</span><br><span class="line">//    作用：将 Master 实例注册为 RPC 端点（Endpoint），使其他组件（如 Worker、Driver）能通过 RPC 与 Master 通信。</span><br><span class="line">//    参数：</span><br><span class="line">//    ENDPOINT_NAME：固定为 &quot;Master&quot;，作为端点的唯一标识。</span><br><span class="line">//    new Master(...)：创建 Master 实例，传入以下参数：</span><br><span class="line">//    rpcEnv：Master 的 RPC 环境。</span><br><span class="line">//    rpcEnv.address：Master 自身的 RPC 地址（格式如 spark://host:port）。</span><br><span class="line">//    webUiPort：Web UI 的初始端口。</span><br><span class="line">//    securityMgr 和 conf：安全管理和配置。</span><br><span class="line">//    底层实现：</span><br><span class="line">//    Master 类继承自 ThreadSafeRpcEndpoint，实现 RPC 消息处理逻辑（如 receiveAndReply）。</span><br><span class="line">//    将 Master 实例注册到 rpcEnv 的端点映射表中。</span><br><span class="line">    val masterEndpoint = rpcEnv.setupEndpoint(ENDPOINT_NAME,</span><br><span class="line">      new Master(rpcEnv, rpcEnv.address, webUiPort, securityMgr, conf))</span><br><span class="line">//    作用：通过 RPC 同步请求，获取 Master 实际绑定的端口（如 Web UI 和 REST API 端口）。</span><br><span class="line">//    消息交互：</span><br><span class="line">//    发送 BoundPortsRequest 消息到 masterEndpoint。</span><br><span class="line">//    等待并接收 BoundPortsResponse 响应，包含：</span><br><span class="line">//    webUIPort：Web UI 的实际端口（若初始 webUiPort=0，这里是系统分配的端口）。</span><br><span class="line">//    restPort：REST API 端口（若启用 REST 服务，否则为 None）。</span><br><span class="line">//    实现细节：</span><br><span class="line">//    BoundPortsRequest 是 Master 内部处理的消息类型，触发 Master 返回当前绑定的端口信息。</span><br><span class="line">//    askSync 是同步阻塞调用，确保获取到实际端口后再继续执行。</span><br><span class="line">    val portsResponse = masterEndpoint.askSync[BoundPortsResponse](BoundPortsRequest)</span><br><span class="line">//    返回值：rpcEnv：Master 的 RPC 环境，用于后续通信。</span><br><span class="line">//    portsResponse.webUIPort：Web UI 的实际端口（如 8080）。</span><br><span class="line">//    portsResponse.restPort：REST API 端口（如 6066），若未启用则为 None。</span><br><span class="line">    (rpcEnv, portsResponse.webUIPort, portsResponse.restPort)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-代码解析"><a href="#2-代码解析" class="headerlink" title="(2) 代码解析"></a>(2) 代码解析</h4><ul>
<li>源代码路径：org.apache.spark.deploy.master.Master#main</li>
<li>将Master实例注册为RPC端点（Endpoint），使其他组件（如Worker、Driver）能通过RPC与Master通信</li>
<li>Master实例注册为RPC端点后，会自动启动onStart()函数</li>
</ul>
<h3 id="2-通过自启动onStart-方法，master节点开始与zookeeper集群进行初始化连接，并进行选举Leader"><a href="#2-通过自启动onStart-方法，master节点开始与zookeeper集群进行初始化连接，并进行选举Leader" class="headerlink" title="2.通过自启动onStart()方法，master节点开始与zookeeper集群进行初始化连接，并进行选举Leader"></a>2.通过自启动onStart()方法，master节点开始与zookeeper集群进行初始化连接，并进行选举Leader</h3><h4 id="1-代码-1"><a href="#1-代码-1" class="headerlink" title="(1) 代码"></a>(1) 代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">  override def onStart(): Unit = &#123;</span><br><span class="line">    logInfo(&quot;Starting Spark master at &quot; + masterUrl)</span><br><span class="line">    logInfo(s&quot;Running Spark version $&#123;org.apache.spark.SPARK_VERSION&#125;&quot;)</span><br><span class="line">    webUi = new MasterWebUI(this, webUiPort)</span><br><span class="line">    webUi.bind()</span><br><span class="line">    masterWebUiUrl = webUi.webUrl</span><br><span class="line">    if (reverseProxy) &#123;</span><br><span class="line">      val uiReverseProxyUrl = conf.get(UI_REVERSE_PROXY_URL).map(_.stripSuffix(&quot;/&quot;))</span><br><span class="line">      if (uiReverseProxyUrl.nonEmpty) &#123;</span><br><span class="line">        System.setProperty(&quot;spark.ui.proxyBase&quot;, uiReverseProxyUrl.get)</span><br><span class="line">        // If the master URL has a path component, it must end with a slash.</span><br><span class="line">        // Otherwise the browser generates incorrect relative links</span><br><span class="line">        masterWebUiUrl = uiReverseProxyUrl.get + &quot;/&quot;</span><br><span class="line">      &#125;</span><br><span class="line">      webUi.addProxy()</span><br><span class="line">      logInfo(s&quot;Spark Master is acting as a reverse proxy. Master, Workers and &quot; +</span><br><span class="line">       s&quot;Applications UIs are available at $masterWebUiUrl&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    checkForWorkerTimeOutTask = forwardMessageThread.scheduleAtFixedRate(</span><br><span class="line">      () =&gt; Utils.tryLogNonFatalError &#123; self.send(CheckForWorkerTimeOut) &#125;,</span><br><span class="line">      0, workerTimeoutMs, TimeUnit.MILLISECONDS)</span><br><span class="line"></span><br><span class="line">    if (restServerEnabled) &#123;</span><br><span class="line">      val port = conf.get(MASTER_REST_SERVER_PORT)</span><br><span class="line">      restServer = Some(new StandaloneRestServer(address.host, port, conf, self, masterUrl))</span><br><span class="line">    &#125;</span><br><span class="line">    restServerBoundPort = restServer.map(_.start())</span><br><span class="line"></span><br><span class="line">    masterMetricsSystem.registerSource(masterSource)</span><br><span class="line">    masterMetricsSystem.start()</span><br><span class="line">    applicationMetricsSystem.start()</span><br><span class="line">    // Attach the master and app metrics servlet handler to the web ui after the metrics systems are</span><br><span class="line">    // started.</span><br><span class="line">    masterMetricsSystem.getServletHandlers.foreach(webUi.attachHandler)</span><br><span class="line">    applicationMetricsSystem.getServletHandlers.foreach(webUi.attachHandler)</span><br><span class="line"></span><br><span class="line">    val serializer = new JavaSerializer(conf)</span><br><span class="line">//    当 Master 节点启动时，若配置了 spark.deploy.recoveryMode=ZOOKEEPER，则会在 onStart() 方法中创建 ZooKeeper 相关的持久化引擎和选举代理：</span><br><span class="line">    val (persistenceEngine_, leaderElectionAgent_) = recoveryMode match &#123;</span><br><span class="line">      case &quot;ZOOKEEPER&quot; =&gt;</span><br><span class="line">        logInfo(&quot;Persisting recovery state to ZooKeeper&quot;)</span><br><span class="line">        val zkFactory =</span><br><span class="line">//          ZooKeeperRecoveryModeFactory：工厂类，用于创建与 ZooKeeper 交互的组件。</span><br><span class="line">          new ZooKeeperRecoveryModeFactory(conf, serializer)</span><br><span class="line">//       createPersistenceEngine()：创建 ZooKeeperPersistenceEngine，负责将集群状态（Workers、Applications）持久化到 ZooKeeper。</span><br><span class="line">//       createLeaderElectionAgent()：创建 ZooKeeperLeaderElectionAgent，负责通过 ZooKeeper 选举 Leader。</span><br><span class="line">        /**</span><br><span class="line">         * ZooKeeperLeaderElectionAgent 是 Leader 选举的核心类，其工作流程如下：</span><br><span class="line">         * 1 连接 ZooKeeper 集群</span><br><span class="line">         * 初始化连接：ZooKeeperLeaderElectionAgent 在构造时，会根据配置的 ZooKeeper 地址（spark.deploy.zookeeper.url）连接到 ZooKeeper 集群。</span><br><span class="line">         * 创建选举节点：在 ZooKeeper 的指定路径（如 /spark/master）下创建临时顺序节点（Ephemeral Sequential Node），例如：</span><br><span class="line">         * /spark/master/_c_5e3e1e6c-lock-0000000001</span><br><span class="line">         * /spark/master/_c_5e3e1e6c-lock-0000000002</span><br><span class="line">         * 2 选举 Leader</span><br><span class="line">         * 节点排序：所有参与选举的 Master 节点会在同一路径下创建临时顺序节点。ZooKeeper 会为每个节点分配全局唯一的递增序号。</span><br><span class="line">         * 最小序号为 Leader：序号最小的节点成为 Leader。例如，若节点序号为 0000000001 和 0000000002，则序号为 0000000001 的节点成为 Leader。</span><br><span class="line">         * 监听前序节点：非 Leader 节点会监听比它序号小的前一个节点的删除事件。如果前序节点被删除（例如 Leader 宕机），当前节点会自动成为新的 Leader。</span><br><span class="line">         * 3 选举回调</span><br><span class="line">         * 当选 Leader：当节点成为 Leader 时，ZooKeeper 会触发回调函数 updateLeadershipStatus(true)，调用 Master.electedLeader()。</span><br><span class="line">         * 失去 Leader：当节点失去 Leader 身份时，触发 updateLeadershipStatus(false)，调用 Master.revokedLeadership()。</span><br><span class="line">         */</span><br><span class="line">        (zkFactory.createPersistenceEngine(), zkFactory.createLeaderElectionAgent(this))</span><br><span class="line">      case &quot;FILESYSTEM&quot; =&gt;</span><br><span class="line">        val fsFactory =</span><br><span class="line">          new FileSystemRecoveryModeFactory(conf, serializer)</span><br><span class="line">        (fsFactory.createPersistenceEngine(), fsFactory.createLeaderElectionAgent(this))</span><br><span class="line">      case &quot;CUSTOM&quot; =&gt;</span><br><span class="line">        val clazz = Utils.classForName(conf.get(RECOVERY_MODE_FACTORY))</span><br><span class="line">        val factory = clazz.getConstructor(classOf[SparkConf], classOf[Serializer])</span><br><span class="line">          .newInstance(conf, serializer)</span><br><span class="line">          .asInstanceOf[StandaloneRecoveryModeFactory]</span><br><span class="line">        (factory.createPersistenceEngine(), factory.createLeaderElectionAgent(this))</span><br><span class="line">      case _ =&gt;</span><br><span class="line">        (new BlackHolePersistenceEngine(), new MonarchyLeaderAgent(this))</span><br><span class="line">    &#125;</span><br><span class="line">    persistenceEngine = persistenceEngine_</span><br><span class="line">    leaderElectionAgent = leaderElectionAgent_</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-代码解析-1"><a href="#2-代码解析-1" class="headerlink" title="(2) 代码解析"></a>(2) 代码解析</h4><ul>
<li>源代码路径：org.apache.spark.deploy.master.Master#onStart</li>
<li>当Master节点启动时，若配置了spark.deploy.recoveryMode&#x3D;ZOOKEEPER，则会在onStart()方法中创建ZooKeeper相关的持久化引擎和选举代理</li>
</ul>
<h3 id="3-初始化连接zookeeper后，进行leader的选举和对worker，driver节点进行持久化"><a href="#3-初始化连接zookeeper后，进行leader的选举和对worker，driver节点进行持久化" class="headerlink" title="3.初始化连接zookeeper后，进行leader的选举和对worker，driver节点进行持久化"></a>3.初始化连接zookeeper后，进行leader的选举和对worker，driver节点进行持久化</h3><h4 id="1-代码-2"><a href="#1-代码-2" class="headerlink" title="(1) 代码"></a>(1) 代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">//在 Spark 的 Master 高可用（HA）实现中，Master 类实现了 LeaderElectable 接口，因此 masterInstance 实际指向的是 Master 类的实例。</span><br><span class="line">private[master] class ZooKeeperLeaderElectionAgent(val masterInstance: LeaderElectable,</span><br><span class="line">    conf: SparkConf) extends LeaderLatchListener with LeaderElectionAgent with Logging  &#123;</span><br><span class="line"></span><br><span class="line">  val workingDir = conf.get(ZOOKEEPER_DIRECTORY).getOrElse(&quot;/spark&quot;) + &quot;/leader_election&quot;</span><br><span class="line"></span><br><span class="line">  private var zk: CuratorFramework = _</span><br><span class="line">  private var leaderLatch: LeaderLatch = _</span><br><span class="line">  private var status = LeadershipStatus.NOT_LEADER</span><br><span class="line"></span><br><span class="line">  start()</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * isLeader() 函数的调用位置</span><br><span class="line">   * isLeader() 函数是由 LeaderLatch 的内部机制调用的，具体来说，在 Leader 节点发生变化时，LeaderLatch 会触发 LeaderLatchListener</span><br><span class="line">   * 的相关回调函数，包括 isLeader() 和 notLeader()。LeaderLatch 是 Apache Curator 提供的一个类，它用于实现基于 Zookeeper 的</span><br><span class="line">   * leader 选举。当 Leader 节点的状态发生变化时（例如节点从非领导者变为领导者，或者从领导者变为非领导者），LeaderLatch 会回调相应的监听器方法。</span><br><span class="line">   * 在本类中，ZooKeeperLeaderElectionAgent 实现了 LeaderLatchListener，因此这些回调方法（isLeader() 和 notLeader()）会在 Leader 变更时自动被调用。</span><br><span class="line">   *</span><br><span class="line">   * 选举 Leader</span><br><span class="line">   * 节点排序：所有参与选举的 Master 节点会在同一路径下创建临时顺序节点。ZooKeeper 会为每个节点分配全局唯一的递增序号。</span><br><span class="line">   * 最小序号为 Leader：序号最小的节点成为 Leader。例如，若节点序号为 0000000001 和 0000000002，则序号为 0000000001 的节点成为 Leader。</span><br><span class="line">   * 监听前序节点：非 Leader 节点会监听比它序号小的前一个节点的删除事件。如果前序节点被删除（例如 Leader 宕机），当前节点会自动成为新的 Leader。</span><br><span class="line">   *</span><br><span class="line">   *  选举回调</span><br><span class="line">   *  当选 Leader：当节点成为 Leader 时，ZooKeeper 会触发回调函数 updateLeadershipStatus(true)，调用 Master.electedLeader()。</span><br><span class="line">   *  失去 Leader：当节点失去 Leader 身份时，触发 updateLeadershipStatus(false)，调用 Master.revokedLeadership()。</span><br><span class="line">   */</span><br><span class="line">  private def start(): Unit = &#123;</span><br><span class="line">    logInfo(&quot;Starting ZooKeeper LeaderElection agent&quot;)</span><br><span class="line">//    初始化连接：ZooKeeperLeaderElectionAgent 在构造时，会根据配置的 ZooKeeper 地址（spark.deploy.zookeeper.url）连接到 ZooKeeper 集群。</span><br><span class="line">    zk = SparkCuratorUtil.newClient(conf)</span><br><span class="line">//    创建选举节点：在 ZooKeeper 的指定路径（如 /spark/master）下创建临时顺序节点（Ephemeral Sequential Node），例如：</span><br><span class="line">//    /spark/master/_c_5e3e1e6c-lock-0000000001</span><br><span class="line">//    /spark/master/_c_5e3e1e6c-lock-0000000002</span><br><span class="line">    leaderLatch = new LeaderLatch(zk, workingDir)</span><br><span class="line">    leaderLatch.addListener(this)  // 注册监听器</span><br><span class="line">    //    leaderLatch.start() 在 start() 方法中被调用，初始化并启动了 leader 选举。</span><br><span class="line">//    在 LeaderLatch 内部，一旦当前节点成为了 Leader，isLeader() 会被触发。此时，它会执行更新领导状态的逻辑，</span><br><span class="line">    //    并调用 masterInstance.electedLeader() 来通知 Master 节点，表明当前节点已经成为了 Leader。</span><br><span class="line">    leaderLatch.start()  // 启动 leader 选举</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  override def stop(): Unit = &#123;</span><br><span class="line">    leaderLatch.close()</span><br><span class="line">    zk.close()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 当 Leader 节点状态变化时，Zookeeper 会通过 Curator Framework 调用 LeaderLatchListener 的回调方法。具体来说：</span><br><span class="line">   * 如果当前节点成为了 Leader，isLeader() 方法会被触发，执行 updateLeadershipStatus(true)。</span><br><span class="line">   * 如果当前节点失去领导权，notLeader() 方法会被触发，执行 updateLeadershipStatus(false)。</span><br><span class="line">   * isLeader() 被调用后，会更新领导状态，并通知 masterInstance 通过 masterInstance.electedLeader() 将状态更新为领导者。</span><br><span class="line">   */</span><br><span class="line">  override def isLeader(): Unit = &#123;</span><br><span class="line">    synchronized &#123;</span><br><span class="line">      // could have lost leadership by now.</span><br><span class="line">//      在这里，leaderLatch.hasLeadership 判断当前节点是否为 Leader，如果是，就更新状态，并执行 updateLeadershipStatus(true)。</span><br><span class="line">      if (!leaderLatch.hasLeadership) &#123;</span><br><span class="line">        return</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      logInfo(&quot;We have gained leadership&quot;)</span><br><span class="line">      updateLeadershipStatus(true)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  override def notLeader(): Unit = &#123;</span><br><span class="line">    synchronized &#123;</span><br><span class="line">      // could have gained leadership by now.</span><br><span class="line">      if (leaderLatch.hasLeadership) &#123;</span><br><span class="line">        return</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      logInfo(&quot;We have lost leadership&quot;)</span><br><span class="line">      updateLeadershipStatus(false)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * 这段代码更新了节点的领导身份状态，并通过 masterInstance.electedLeader() 或 masterInstance.revokedLeadership() 通知 Master 节点。</span><br><span class="line">   * electedLeader() 和 revokedLeadership() 的实现，这两个方法是 LeaderElectable 接口的核心方法，Master 类通过实现它们来处理 Leader 状态的变更。</span><br><span class="line">   * @param isLeader</span><br><span class="line">   */</span><br><span class="line">  private def updateLeadershipStatus(isLeader: Boolean): Unit = &#123;</span><br><span class="line">    if (isLeader &amp;&amp; status == LeadershipStatus.NOT_LEADER) &#123;</span><br><span class="line">      status = LeadershipStatus.LEADER</span><br><span class="line">      // 通知 Master 节点当前已成为 Leader</span><br><span class="line">      masterInstance.electedLeader()</span><br><span class="line">    &#125; else if (!isLeader &amp;&amp; status == LeadershipStatus.LEADER) &#123;</span><br><span class="line">      status = LeadershipStatus.NOT_LEADER</span><br><span class="line">      // 通知 Master 节点当前已失去 Leader 身份</span><br><span class="line">      masterInstance.revokedLeadership()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  private object LeadershipStatus extends Enumeration &#123;</span><br><span class="line">    type LeadershipStatus = Value</span><br><span class="line">    val LEADER, NOT_LEADER = Value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-代码解析-2"><a href="#2-代码解析-2" class="headerlink" title="(2) 代码解析"></a>(2) 代码解析</h4><ul>
<li>源代码路径：org.apache.spark.deploy.master.ZooKeeperLeaderElectionAgent</li>
<li>在对 ZooKeeperLeaderElectionAgent 类进行初始化的时候，自动调用了start() 函数</li>
<li>在执行zk &#x3D; SparkCuratorUtil.newClient(conf)代码的时候，该master节点连接到zookeeper集群</li>
<li>leaderLatch &#x3D; new LeaderLatch(zk, workingDir)代码会在zookeeper指定路径下面，创建临时顺序节点，spark3.3.0版本的默认路径为&#x2F;spark&#x2F;leader_election</li>
<li>leaderLatch.start()初始化并启动leader选举</li>
<li>选举leader的逻辑<blockquote>
<p>1，节点排序：提前设置好的众多master节点会在连接 zookeeper 后，在 zookeeper 指定同一路径下面创建临时顺序节点，ZooKeeper 会为每个节点分配全局唯一的递增序号。例如：&#x2F;spark&#x2F;leader_election&#x2F;_c_5e3e1e6c-lock-0000000001，&#x2F;spark&#x2F;leader_election&#x2F;_c_5e3e1e6c-lock-0000000002<br>2，最小序号为 Leader：序号最小的节点成为 Leader。例如，若节点序号为 0000000001 和 0000000002，则序号为 0000000001 的节点成为 Leader<br>3，监听前序节点：非 Leader 节点会监听比它序号小的前一个节点的删除事件。如果前序节点被删除（例如 Leader 宕机），当前节点会自动成为新的 Leader</p>
</blockquote>
</li>
<li>leader选举回调策略<blockquote>
<p>1，当选 Leader：当节点成为 Leader 时，ZooKeeper 会触发回调函数 updateLeadershipStatus(true)，调用 Master.electedLeader()。<br>2，失去 Leader：当节点失去 Leader 身份时，触发 updateLeadershipStatus(false)，调用 Master.revokedLeadership()</p>
</blockquote>
</li>
</ul>
<h3 id="4-master节点被选举为leader的详细过程"><a href="#4-master节点被选举为leader的详细过程" class="headerlink" title="4.master节点被选举为leader的详细过程"></a>4.master节点被选举为leader的详细过程</h3><h4 id="1-代码-3"><a href="#1-代码-3" class="headerlink" title="(1) 代码"></a>(1) 代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">override def electedLeader(): Unit = &#123;</span><br><span class="line">    self.send(ElectedLeader)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">case ElectedLeader =&gt;</span><br><span class="line"></span><br><span class="line">			/**</span><br><span class="line">			 * persistenceEngine.readPersistedData(rpcEnv): 从持久化存储（如 ZooKeeper）中读取集群的持久化数据，包括：</span><br><span class="line">			 * storedApps: 已注册的 Application 列表。</span><br><span class="line">			 * storedDrivers: 已注册的 Driver 列表。</span><br><span class="line">			 * storedWorkers: 已注册的 Worker 列表。</span><br><span class="line">			 */</span><br><span class="line">      val (storedApps, storedDrivers, storedWorkers) = persistenceEngine.readPersistedData(rpcEnv)</span><br><span class="line">			/**</span><br><span class="line">			 * state: 是 Master 的状态变量，表示当前 Master 的状态。</span><br><span class="line">			 * 判断逻辑:</span><br><span class="line">			 * 如果持久化数据为空（即没有已注册的 Application、Driver 和 Worker），则将状态设置为 RecoveryState.ALIVE。</span><br><span class="line">			 * 如果持久化数据不为空，则将状态设置为 RecoveryState.RECOVERING，表示需要恢复集群状态。</span><br><span class="line">			 */</span><br><span class="line">      state = if (storedApps.isEmpty &amp;&amp; storedDrivers.isEmpty &amp;&amp; storedWorkers.isEmpty) &#123;</span><br><span class="line">        RecoveryState.ALIVE</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        RecoveryState.RECOVERING</span><br><span class="line">      &#125;</span><br><span class="line">//			logInfo: 记录一条日志，表示当前节点已被选举为 Leader，并显示新的状态。</span><br><span class="line">      logInfo(&quot;I have been elected leader! New state: &quot; + state)</span><br><span class="line"></span><br><span class="line">      if (state == RecoveryState.RECOVERING) &#123;</span><br><span class="line">//				beginRecovery(storedApps, storedDrivers, storedWorkers): 开始恢复集群状态，具体逻辑包括：</span><br><span class="line">//				重新注册已持久化的 Application、Driver 和 Worker。</span><br><span class="line">//				检查 Worker 的存活状态。</span><br><span class="line">        beginRecovery(storedApps, storedDrivers, storedWorkers)</span><br><span class="line">//				recoveryCompletionTask: 设置一个定时任务，在 workerTimeoutMs 毫秒后发送 CompleteRecovery 消息。</span><br><span class="line">//				forwardMessageThread.schedule: 使用线程池安排一个定时任务。</span><br><span class="line">//				self.send(CompleteRecovery): 向 Master 自己发送 CompleteRecovery 消息，表示恢复完成。</span><br><span class="line">//				recoveryCompletionTask = forwardMessageThread.schedule(...) 这段代码的作用是 延迟 workerTimeoutMs 时间后，</span><br><span class="line">//				只执行一次 run() 函数，而不是周期性执行。</span><br><span class="line">				recoveryCompletionTask = forwardMessageThread.schedule(new Runnable &#123;</span><br><span class="line">          override def run(): Unit = Utils.tryLogNonFatalError &#123;</span><br><span class="line">            self.send(CompleteRecovery)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, workerTimeoutMs, TimeUnit.MILLISECONDS)</span><br><span class="line">      &#125;</span><br><span class="line">case RevokedLeadership =&gt;</span><br><span class="line">    logError(&quot;Leadership has been revoked -- master shutting down.&quot;)</span><br><span class="line">    System.exit(0)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private def beginRecovery(storedApps: Seq[ApplicationInfo], storedDrivers: Seq[DriverInfo],</span><br><span class="line">      storedWorkers: Seq[WorkerInfo]): Unit = &#123;</span><br><span class="line">//		恢复 Application：</span><br><span class="line">    for (app &lt;- storedApps) &#123;</span><br><span class="line">      logInfo(&quot;Trying to recover app: &quot; + app.id)</span><br><span class="line">      try &#123;</span><br><span class="line">//				重新注册已持久化的 Application。</span><br><span class="line">        registerApplication(app)</span><br><span class="line">//				将 Application 的状态设置为 UNKNOWN，表示需要重新确认状态。</span><br><span class="line">        app.state = ApplicationState.UNKNOWN</span><br><span class="line">//				向 Application 的 Driver 发送 MasterChanged 消息，通知它 Master 节点的变化。</span><br><span class="line">//				MasterChanged(self, masterWebUiUrl): 包含新的 Master 节点的 RPC 引用和 Web UI 地址。</span><br><span class="line">        app.driver.send(MasterChanged(self, masterWebUiUrl))</span><br><span class="line">      &#125; catch &#123;</span><br><span class="line">        case e: Exception =&gt; logInfo(&quot;App &quot; + app.id + &quot; had exception on reconnect&quot;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (driver &lt;- storedDrivers) &#123;</span><br><span class="line">      // Here we just read in the list of drivers. Any drivers associated with now-lost workers</span><br><span class="line">      // will be re-launched when we detect that the worker is missing.</span><br><span class="line">//			将 Driver 添加到 Master 的 drivers 列表中。</span><br><span class="line">//			这里只是将 Driver 列表读入内存。</span><br><span class="line">//			如果某个 Driver 关联的 Worker 已经丢失，会在检测到 Worker 丢失时重新启动 Driver。</span><br><span class="line">      drivers += driver</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (worker &lt;- storedWorkers) &#123;</span><br><span class="line">      logInfo(&quot;Trying to recover worker: &quot; + worker.id)</span><br><span class="line">      try &#123;</span><br><span class="line">//				将 Worker 添加到 Master 的 workers 列表中。</span><br><span class="line">        registerWorker(worker)</span><br><span class="line">//				更新 Worker 的状态。将 Worker 的状态设置为 UNKNOWN，表示需要重新确认状态。</span><br><span class="line">        worker.state = WorkerState.UNKNOWN</span><br><span class="line">//				向 Worker 发送 MasterChanged 消息，通知它 Master 节点的变化。包含新的 Master 节点的 RPC 引用和 Web UI 地址。</span><br><span class="line">        worker.endpoint.send(MasterChanged(self, masterWebUiUrl))</span><br><span class="line">      &#125; catch &#123;</span><br><span class="line">        case e: Exception =&gt; logInfo(&quot;Worker &quot; + worker.id + &quot; had exception on reconnect&quot;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-代码解析-3"><a href="#2-代码解析-3" class="headerlink" title="(2) 代码解析"></a>(2) 代码解析</h4><ul>
<li>源代码路径：org.apache.spark.deploy.master.Master#beginRecovery</li>
<li>先通过persistenceEngine.readPersistedData(rpcEnv)获取已经注册的Application，Driver，Worker列表</li>
<li>如果获取的Application，Driver，Worker列表都为空，那就证明该集群是首次启动，不需要进行恢复，直接将该master的状态设置为 ALIVE ，否则设置为 RECOVERING</li>
<li>如果是状态为 RECOVERING，调用 beginRecovery() 函数<blockquote>
<p>1，重新注册已经持久化的 Application，将 Application设置为 UNKNOWN，表示需要重新确认状态，通过rpc通信，向 StandaloneAppClient 发送MasterChanged信息，更新 Application 节点的Master节点的 RPC 引用和 Web UI 地址<br>2，将 Driver 添加到 Master 的 drivers 列表中，这里只是将 Driver 列表读入内存<br>3，将 Worker 添加到 Master 的 workers 列表中，更新 Worker 的状态。将 Worker 的状态设置为 UNKNOWN，表示需要重新确认状态。向 Worker 发送 MasterChanged 消息，通知它 Master 节点的变化。包含新的 Master 节点的 RPC 引用和 Web UI 地址。如果 Worker 节点是存活的，会通过 rpc 反馈给 master 节点 WorkerSchedulerStateResponse 信息，在 master 节点上更新该 worker 节点为 ALIVE 状态</p>
</blockquote>
</li>
<li>执行 beginRecovery 函数后，执行一个延迟执行的定时任务 run() 方法，调用 self.send(CompleteRecovery)</li>
</ul>
<h3 id="5-Master-通过-self-send-CompleteRecovery-向自己发送信息，调用-completeRecovery-函数，修改-Master-的状态"><a href="#5-Master-通过-self-send-CompleteRecovery-向自己发送信息，调用-completeRecovery-函数，修改-Master-的状态" class="headerlink" title="5.Master 通过 self.send(CompleteRecovery) 向自己发送信息，调用 completeRecovery() 函数，修改 Master 的状态"></a>5.Master 通过 self.send(CompleteRecovery) 向自己发送信息，调用 completeRecovery() 函数，修改 Master 的状态</h3><h4 id="1-代码-4"><a href="#1-代码-4" class="headerlink" title="(1) 代码"></a>(1) 代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">case CompleteRecovery =&gt; completeRecovery()</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">  private def completeRecovery(): Unit = &#123;</span><br><span class="line">    // Ensure &quot;only-once&quot; recovery semantics using a short synchronization period.</span><br><span class="line">//		检查当前状态是否为 RecoveryState.RECOVERING。如果不是，直接返回，确保恢复逻辑只执行一次。</span><br><span class="line">    if (state != RecoveryState.RECOVERING) &#123; return &#125;</span><br><span class="line">//		将状态设置为 RecoveryState.COMPLETING_RECOVERY，表示正在完成恢复。</span><br><span class="line">    state = RecoveryState.COMPLETING_RECOVERY</span><br><span class="line"></span><br><span class="line">    // Kill off any workers and apps that didn&#x27;t respond to us.</span><br><span class="line">		//		workers.filter(_.state == WorkerState.UNKNOWN): 过滤出状态为 UNKNOWN 的 Worker。</span><br><span class="line">		//		removeWorker(_, &quot;Not responding for recovery&quot;): 移除这些 Worker，并记录移除原因（“未响应恢复”）。</span><br><span class="line">    workers.filter(_.state == WorkerState.UNKNOWN).foreach(</span><br><span class="line">      removeWorker(_, &quot;Not responding for recovery&quot;))</span><br><span class="line">		//		apps.filter(_.state == ApplicationState.UNKNOWN): 过滤出状态为 UNKNOWN 的 Application。</span><br><span class="line">		//		finishApplication: 结束这些 Application，将其状态设置为 FINISHED。</span><br><span class="line">    apps.filter(_.state == ApplicationState.UNKNOWN).foreach(finishApplication)</span><br><span class="line">    // Update the state of recovered apps to RUNNING</span><br><span class="line">		//		apps.filter(_.state == ApplicationState.WAITING): 过滤出状态为 WAITING 的 Application。</span><br><span class="line">		//		_.state = ApplicationState.RUNNING: 将这些 Application 的状态更新为 RUNNING，表示它们可以继续运行。</span><br><span class="line">    apps.filter(_.state == ApplicationState.WAITING).foreach(_.state = ApplicationState.RUNNING)</span><br><span class="line"></span><br><span class="line">    // Reschedule drivers which were not claimed by any workers</span><br><span class="line">		//		drivers.filter(_.worker.isEmpty): 过滤出未分配 Worker 的 Driver（即 worker 字段为空的 Driver）。</span><br><span class="line">    drivers.filter(_.worker.isEmpty).foreach &#123; d =&gt;</span><br><span class="line">		// logWarning(s&quot;Driver $&#123;d.id&#125; was not found after master recovery&quot;): 记录警告日志，表示这些 Driver 在恢复后未找到。</span><br><span class="line">      logWarning(s&quot;Driver $&#123;d.id&#125; was not found after master recovery&quot;)</span><br><span class="line">		//	if (d.desc.supervise): 检查 Driver 是否配置了 supervise 参数（即是否支持自动重启）。</span><br><span class="line">      if (d.desc.supervise) &#123;</span><br><span class="line">		//	如果支持，调用 relaunchDriver(d) 重新启动 Driver。</span><br><span class="line">        logWarning(s&quot;Re-launching $&#123;d.id&#125;&quot;)</span><br><span class="line">        relaunchDriver(d)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">		//	如果不支持，调用 removeDriver(d.id, DriverState.ERROR, None) 移除 Driver，并记录警告日志。</span><br><span class="line">        removeDriver(d.id, DriverState.ERROR, None)</span><br><span class="line">        logWarning(s&quot;Did not re-launch $&#123;d.id&#125; because it was not supervised&quot;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">		//		state = RecoveryState.ALIVE: 将状态设置为 RecoveryState.ALIVE，表示恢复完成，集群恢复正常运行。</span><br><span class="line">    state = RecoveryState.ALIVE</span><br><span class="line">		//		schedule(): 调用 schedule() 方法，开始调度任务和资源。</span><br><span class="line">    schedule()</span><br><span class="line">    logInfo(&quot;Recovery complete - resuming operations!&quot;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-代码解析-4"><a href="#2-代码解析-4" class="headerlink" title="(2) 代码解析"></a>(2) 代码解析</h4><ul>
<li>源代码路径：org.apache.spark.deploy.master.Master#completeRecovery</li>
<li>过滤出在workerTimeoutMs（默认60s）内还没有进行rpc反馈的worker节点，移除这些“未响应恢复”的woker节点</li>
<li>过滤出状态为 UNKNOWN 的 Application，结束这些 Application，将其状态设置为 FINISHED</li>
<li>过滤出状态为 WAITING 的 Application，将这些 Application 的状态更新为 RUNNING，表示它们可以继续运行</li>
<li>过滤出未分配 Worker 的 Driver（即 worker 字段为空的 Driver）</li>
<li>调用 schedule() 方法，开始调度任务和资源</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="使用zookeeper实现leader选举逻辑流程图"><a href="#使用zookeeper实现leader选举逻辑流程图" class="headerlink" title="使用zookeeper实现leader选举逻辑流程图"></a>使用zookeeper实现leader选举逻辑流程图</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">+-------------------+         +-------------------+         +-------------------+</span><br><span class="line">|   Master Node 1   |         |   Master Node 2   |         |   Master Node 3   |</span><br><span class="line">| (Active)          |         | (Standby)         |         | (Standby)         |</span><br><span class="line">+-------------------+         +-------------------+         +-------------------+</span><br><span class="line">          |                             |                             |</span><br><span class="line">          | 1. 创建临时顺序节点         | 2. 创建临时顺序节点         | 3. 创建临时顺序节点</span><br><span class="line">          | (e.g., /spark/_c_00000001)  | (e.g., /spark/_c_00000002)  | (e.g., /spark/_c_00000003)</span><br><span class="line">          v                             v                             v</span><br><span class="line">+---------------------------------------------------------------------------------+</span><br><span class="line">|                                 ZooKeeper Cluster                               |</span><br><span class="line">|   /spark/leader_election/_c_00000001 (Active)                                   |</span><br><span class="line">|   /spark/leader_election/_c_00000002 (Standby, 监听00000001)                    |</span><br><span class="line">|   /spark/leader_election/_c_00000003 (Standby, 监听00000002)                    |</span><br><span class="line">+---------------------------------------------------------------------------------+</span><br><span class="line">          |                             |                             |</span><br><span class="line">          | 4. Active Master宕机         |                             |</span><br><span class="line">          v                             v                             v</span><br><span class="line">+-------------------+         +-------------------+         +-------------------+</span><br><span class="line">|   Master Node 1   |         |   Master Node 2   |         |   Master Node 3   |</span><br><span class="line">| (宕机)            |         | (新Active)        |         | (Standby)         |</span><br><span class="line">+-------------------+         +-------------------+         +-------------------+</span><br><span class="line">          |                             |                             |</span><br><span class="line">          |                             | 5. 检测到00000001消失         |</span><br><span class="line">          |                             | 6. 成为新Active，接管服务      |</span><br><span class="line">          |                             v                             |</span><br><span class="line">          |                   +-------------------+                   |</span><br><span class="line">          |                   | 恢复持久化状态      |                    |</span><br><span class="line">          |                   | 启动RPC/Web UI    |                    |</span><br><span class="line">          |                   +-------------------+                   |</span><br><span class="line">          v                             v                             v</span><br></pre></td></tr></table></figure>
<h3 id="使用zookeeper实现leader选举代码执行调用流程图"><a href="#使用zookeeper实现leader选举代码执行调用流程图" class="headerlink" title="使用zookeeper实现leader选举代码执行调用流程图"></a>使用zookeeper实现leader选举代码执行调用流程图</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">+-----------------------+</span><br><span class="line">|     Master.scala      |</span><br><span class="line">|  (onStart() 方法)     |</span><br><span class="line">+-----------------------+</span><br><span class="line">           |</span><br><span class="line">           | 1. 根据配置选择恢复模式（ZOOKEEPER）</span><br><span class="line">           v</span><br><span class="line">+-----------------------+</span><br><span class="line">| ZooKeeperRecoveryMode |</span><br><span class="line">|     Factory 类        |</span><br><span class="line">+-----------------------+</span><br><span class="line">           |</span><br><span class="line">           | 2. 创建持久化引擎和选举代理</span><br><span class="line">           |    - createPersistenceEngine()</span><br><span class="line">           |    - createLeaderElectionAgent()</span><br><span class="line">           v</span><br><span class="line">+-----------------------+</span><br><span class="line">| ZooKeeperPersistence  |</span><br><span class="line">|      Engine 类        |</span><br><span class="line">| (持久化集群状态到 ZK) |</span><br><span class="line">+-----------------------+</span><br><span class="line">           |</span><br><span class="line">           | 3. 持久化 Worker/Application 状态</span><br><span class="line">           |    - persist()</span><br><span class="line">           |    - unpersist()</span><br><span class="line">           v</span><br><span class="line">+-----------------------+</span><br><span class="line">| ZooKeeperLeaderElection|</span><br><span class="line">|      Agent 类          |</span><br><span class="line">| (处理 ZK 选举逻辑)     |</span><br><span class="line">+-----------------------+</span><br><span class="line">           |</span><br><span class="line">           | 4. 连接到 ZooKeeper</span><br><span class="line">           |    - 创建临时顺序节点（Ephemeral Sequential Node）</span><br><span class="line">           |    - 监听节点变化</span><br><span class="line">           v</span><br><span class="line">+-----------------------+</span><br><span class="line">|   ZooKeeper 集群       |</span><br><span class="line">| (维护选举和持久化状态) |</span><br><span class="line">+-----------------------+</span><br><span class="line">           |</span><br><span class="line">           | 5. 选举结果回调</span><br><span class="line">           |    - updateLeadershipStatus(isLeader: Boolean)</span><br><span class="line">           v</span><br><span class="line">+-----------------------+</span><br><span class="line">|      Master.scala     |</span><br><span class="line">|     (处理选举结果)    |</span><br><span class="line">+-----------------------+</span><br><span class="line">           |</span><br><span class="line">           | 6. 当选 Leader：</span><br><span class="line">           |    - electedLeader()</span><br><span class="line">           |      - 启动 RPC 服务</span><br><span class="line">           |      - 恢复持久化状态</span><br><span class="line">           |      - 调度任务</span><br><span class="line">           |</span><br><span class="line">           | 7. 失去 Leader：</span><br><span class="line">           |    - revokedLeadership()</span><br><span class="line">           |      - 关闭 RPC 服务</span><br><span class="line">           |      - 清理状态</span><br><span class="line">           v</span><br><span class="line">+-----------------------+</span><br><span class="line">|集群状态同步与任务调度   |</span><br><span class="line">+-----------------------+</span><br></pre></td></tr></table></figure>
<h3 id="关键点总结"><a href="#关键点总结" class="headerlink" title="关键点总结"></a>关键点总结</h3><ul>
<li>启动master节点后，master节点与zookeeper集群建立连接，各个master节点会在一个指定的路径创建顺序节点，节点序号最小的Master成为Active Master，其余为Standby Master</li>
<li>Standby Master监听比自身序号小的前一个节点，若前序节点消失（如Active Master宕机），触发重新选举，新最小序号节点成为Active</li>
<li>在进行重新选举leader成功后，会自动恢复上一个leader在zookeeper持久化的application，driver，worker，并进行逐个rpc确认，如果在指定时间内没有反馈，就直接过滤掉</li>
<li>在leader切换完成后，会调用 schedule() 方法，开始调度任务和资源</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://nrliangxy.github.io/yunshenBlog.github.io">nrliangxy</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://nrliangxy.github.io/yunshenBlog.github.io/2025/03/21/zookeeper-master-select-leader/">https://nrliangxy.github.io/yunshenBlog.github.io/2025/03/21/zookeeper-master-select-leader/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/yunshenBlog.github.io/tags/spark-3-3-0/">spark 3.3.0</a><a class="post-meta__tags" href="/yunshenBlog.github.io/tags/standalone/">standalone</a><a class="post-meta__tags" href="/yunshenBlog.github.io/tags/rpc/">rpc</a><a class="post-meta__tags" href="/yunshenBlog.github.io/tags/master/">master</a><a class="post-meta__tags" href="/yunshenBlog.github.io/tags/zookeeper/">zookeeper</a></div><div class="post-share"><div class="social-share" data-image="/yunshenBlog.github.io/img/butterfly-icon.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/yunshenBlog.github.io/2025/03/06/spark-work-master-rpc/" title="spark在standalone模式下，worker与master的rpc通信流程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">Previous</div><div class="info-item-2">spark在standalone模式下，worker与master的rpc通信流程</div></div><div class="info-2"><div class="info-item-1">&emsp;&emsp; 背景 spark集群在standalone模式下，在集群的sbin目录下，启动start-worker.sh脚本，启动了worker端点 worker端点启动后，读取配置后，在spark的rpc通信框架里面注册rpc端点，和master节点进行rpc通信并进行心跳交互 本文就是要详细探讨一下work节点是如何与master节点进行rpc通信  流程梳理1.使用start-worker.sh脚本启动worker节点(1) 在客户端提交命令样例1bash start-worker.sh  (2) 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647  def main(argStrings: Array[String]): Unit = &#123;//    设置一个默认的未捕获异常处理器 SparkUncaughtExceptionHandler。//    exitOnUncaughtException = false...</div></div></div></a><a class="pagination-related" href="/yunshenBlog.github.io/2025/03/28/spark-master-dispatch/" title="spark在standalone模式下，Master如何实现资源的调度和分配"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">spark在standalone模式下，Master如何实现资源的调度和分配</div></div><div class="info-2"><div class="info-item-1">&emsp;&emsp; 背景 spark集群在 standalone 模式下，Master 通过函数schedule()来刷新资源情况，同时启动 Executor 的调度逻辑，为 Application 分配 Executor 资源  流程梳理1，调用scheduler()函数（1）代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960  /**   * Schedule the currently available resources among waiting apps. This method will be called   * every time a new app joins or resource availability changes.   * 调度集群资源，启动等待的 Driver 和 Executor。   * 核心逻辑：   * 检查 Master...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/yunshenBlog.github.io/2025/02/25/spark-driver-master-rpc/" title="spark在standalone模式下，driver&#x2F;application与master的rpc通信流程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-25</div><div class="info-item-2">spark在standalone模式下，driver&#x2F;application与master的rpc通信流程</div></div><div class="info-2"><div class="info-item-1">&emsp;&emsp; 背景 spark集群在standalone模式下，在使用client模式下提交application的时候，driver运行在客户端机器上 如果客户端机器崩溃或者driver进程退出，application会失败 由于driver不在集群中，master无法直接管理driver的生命周期 本次只讨论在standalone模式下，使用client模式向master提交application的时候，driver和application与master的通信流程  流程梳理1.在客户端服务器上面提交application(1) 在客户端提交命令样例12345spark-submit --master spark://&lt;master-ip&gt;:&lt;master-port&gt; \  --deploy-mode client \  --class &lt;main-class&gt; \  &lt;application-jar&gt; \  &lt;application-args&gt;  (2)...</div></div></div></a><a class="pagination-related" href="/yunshenBlog.github.io/2025/03/06/spark-work-master-rpc/" title="spark在standalone模式下，worker与master的rpc通信流程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-06</div><div class="info-item-2">spark在standalone模式下，worker与master的rpc通信流程</div></div><div class="info-2"><div class="info-item-1">&emsp;&emsp; 背景 spark集群在standalone模式下，在集群的sbin目录下，启动start-worker.sh脚本，启动了worker端点 worker端点启动后，读取配置后，在spark的rpc通信框架里面注册rpc端点，和master节点进行rpc通信并进行心跳交互 本文就是要详细探讨一下work节点是如何与master节点进行rpc通信  流程梳理1.使用start-worker.sh脚本启动worker节点(1) 在客户端提交命令样例1bash start-worker.sh  (2) 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647  def main(argStrings: Array[String]): Unit = &#123;//    设置一个默认的未捕获异常处理器 SparkUncaughtExceptionHandler。//    exitOnUncaughtException = false...</div></div></div></a><a class="pagination-related" href="/yunshenBlog.github.io/2025/03/28/spark-master-dispatch/" title="spark在standalone模式下，Master如何实现资源的调度和分配"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-28</div><div class="info-item-2">spark在standalone模式下，Master如何实现资源的调度和分配</div></div><div class="info-2"><div class="info-item-1">&emsp;&emsp; 背景 spark集群在 standalone 模式下，Master 通过函数schedule()来刷新资源情况，同时启动 Executor 的调度逻辑，为 Application 分配 Executor 资源  流程梳理1，调用scheduler()函数（1）代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960  /**   * Schedule the currently available resources among waiting apps. This method will be called   * every time a new app joins or resource availability changes.   * 调度集群资源，启动等待的 Driver 和 Executor。   * 核心逻辑：   * 检查 Master...</div></div></div></a><a class="pagination-related" href="/yunshenBlog.github.io/2025/04/18/spark-master-to-executor-task/" title="spark-master-to-executor-task"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-18</div><div class="info-item-2">spark-master-to-executor-task</div></div><div class="info-2"><div class="info-item-1">&emsp;&emsp; 背景 spark集群在 standalone 模式下，Master 通过函数launchExecutor()通知 Worker 和 Driver 要启动一个新的 Executor，后续 Worker 和 Driver 端都是如何进行通信启动和执行 Executor？  流程梳理1，消息会发送到 Worker 的 endpoint，这是 Worker 接收消息的端点。通过这种方式，Master 告诉 Worker 启动一个新的 Executor 并为其分配资源（1）代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899case LaunchExecutor(masterUrl, appId, execId, appDesc,...</div></div></div></a><a class="pagination-related" href="/yunshenBlog.github.io/2025/02/08/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/" title="spark在standalone模式下，FIFO和FAIR调度模式的对象分析"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-08</div><div class="info-item-2">spark在standalone模式下，FIFO和FAIR调度模式的对象分析</div></div><div class="info-2"><div class="info-item-1">...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/yunshenBlog.github.io/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/yunshenBlog.github.io/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">nrliangxy</div><div class="author-info-description"></div><div class="site-data"><a href="/yunshenBlog.github.io/archives/"><div class="headline">Articles</div><div class="length-num">6</div></a><a href="/yunshenBlog.github.io/tags/"><div class="headline">Tags</div><div class="length-num">11</div></a><a href="/yunshenBlog.github.io/categories/"><div class="headline">Categories</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%83%8C%E6%99%AF"><span class="toc-number">1.</span> <span class="toc-text">背景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B%E6%A2%B3%E7%90%86"><span class="toc-number">2.</span> <span class="toc-text">流程梳理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%A6%96%E6%AC%A1%E5%90%AF%E5%8A%A8spark%E9%9B%86%E7%BE%A4%E7%9A%84master%E8%8A%82%E7%82%B9%EF%BC%8C%E4%BD%BF%E7%94%A8start-master-sh%E6%9D%A5%E5%90%AF%E5%8A%A8master%E8%8A%82%E7%82%B9"><span class="toc-number">2.1.</span> <span class="toc-text">1.首次启动spark集群的master节点，使用start-master.sh来启动master节点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BB%A3%E7%A0%81"><span class="toc-number">2.1.1.</span> <span class="toc-text">(1) 代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="toc-number">2.1.2.</span> <span class="toc-text">(2) 代码解析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%80%9A%E8%BF%87%E8%87%AA%E5%90%AF%E5%8A%A8onStart-%E6%96%B9%E6%B3%95%EF%BC%8Cmaster%E8%8A%82%E7%82%B9%E5%BC%80%E5%A7%8B%E4%B8%8Ezookeeper%E9%9B%86%E7%BE%A4%E8%BF%9B%E8%A1%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%9E%E6%8E%A5%EF%BC%8C%E5%B9%B6%E8%BF%9B%E8%A1%8C%E9%80%89%E4%B8%BELeader"><span class="toc-number">2.2.</span> <span class="toc-text">2.通过自启动onStart()方法，master节点开始与zookeeper集群进行初始化连接，并进行选举Leader</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BB%A3%E7%A0%81-1"><span class="toc-number">2.2.1.</span> <span class="toc-text">(1) 代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90-1"><span class="toc-number">2.2.2.</span> <span class="toc-text">(2) 代码解析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%88%9D%E5%A7%8B%E5%8C%96%E8%BF%9E%E6%8E%A5zookeeper%E5%90%8E%EF%BC%8C%E8%BF%9B%E8%A1%8Cleader%E7%9A%84%E9%80%89%E4%B8%BE%E5%92%8C%E5%AF%B9worker%EF%BC%8Cdriver%E8%8A%82%E7%82%B9%E8%BF%9B%E8%A1%8C%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">2.3.</span> <span class="toc-text">3.初始化连接zookeeper后，进行leader的选举和对worker，driver节点进行持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BB%A3%E7%A0%81-2"><span class="toc-number">2.3.1.</span> <span class="toc-text">(1) 代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90-2"><span class="toc-number">2.3.2.</span> <span class="toc-text">(2) 代码解析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-master%E8%8A%82%E7%82%B9%E8%A2%AB%E9%80%89%E4%B8%BE%E4%B8%BAleader%E7%9A%84%E8%AF%A6%E7%BB%86%E8%BF%87%E7%A8%8B"><span class="toc-number">2.4.</span> <span class="toc-text">4.master节点被选举为leader的详细过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BB%A3%E7%A0%81-3"><span class="toc-number">2.4.1.</span> <span class="toc-text">(1) 代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90-3"><span class="toc-number">2.4.2.</span> <span class="toc-text">(2) 代码解析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-Master-%E9%80%9A%E8%BF%87-self-send-CompleteRecovery-%E5%90%91%E8%87%AA%E5%B7%B1%E5%8F%91%E9%80%81%E4%BF%A1%E6%81%AF%EF%BC%8C%E8%B0%83%E7%94%A8-completeRecovery-%E5%87%BD%E6%95%B0%EF%BC%8C%E4%BF%AE%E6%94%B9-Master-%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">2.5.</span> <span class="toc-text">5.Master 通过 self.send(CompleteRecovery) 向自己发送信息，调用 completeRecovery() 函数，修改 Master 的状态</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BB%A3%E7%A0%81-4"><span class="toc-number">2.5.1.</span> <span class="toc-text">(1) 代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90-4"><span class="toc-number">2.5.2.</span> <span class="toc-text">(2) 代码解析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">3.</span> <span class="toc-text">总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8zookeeper%E5%AE%9E%E7%8E%B0leader%E9%80%89%E4%B8%BE%E9%80%BB%E8%BE%91%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="toc-number">3.1.</span> <span class="toc-text">使用zookeeper实现leader选举逻辑流程图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8zookeeper%E5%AE%9E%E7%8E%B0leader%E9%80%89%E4%B8%BE%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="toc-number">3.2.</span> <span class="toc-text">使用zookeeper实现leader选举代码执行调用流程图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E7%82%B9%E6%80%BB%E7%BB%93"><span class="toc-number">3.3.</span> <span class="toc-text">关键点总结</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/yunshenBlog.github.io/2025/04/18/spark-master-to-executor-task/" title="spark-master-to-executor-task">spark-master-to-executor-task</a><time datetime="2025-04-17T22:53:11.000Z" title="Created 2025-04-18 06:53:11">2025-04-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/yunshenBlog.github.io/2025/03/28/spark-master-dispatch/" title="spark在standalone模式下，Master如何实现资源的调度和分配">spark在standalone模式下，Master如何实现资源的调度和分配</a><time datetime="2025-03-28T01:57:10.000Z" title="Created 2025-03-28 09:57:10">2025-03-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/yunshenBlog.github.io/2025/03/21/zookeeper-master-select-leader/" title="spark在standalone模式下，使用zookeeper进行master选举流程剖析">spark在standalone模式下，使用zookeeper进行master选举流程剖析</a><time datetime="2025-03-21T03:57:09.000Z" title="Created 2025-03-21 11:57:09">2025-03-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/yunshenBlog.github.io/2025/03/06/spark-work-master-rpc/" title="spark在standalone模式下，worker与master的rpc通信流程">spark在standalone模式下，worker与master的rpc通信流程</a><time datetime="2025-03-06T01:13:14.000Z" title="Created 2025-03-06 09:13:14">2025-03-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/yunshenBlog.github.io/2025/02/25/spark-driver-master-rpc/" title="spark在standalone模式下，driver/application与master的rpc通信流程">spark在standalone模式下，driver/application与master的rpc通信流程</a><time datetime="2025-02-25T12:27:00.000Z" title="Created 2025-02-25 20:27:00">2025-02-25</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By nrliangxy</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/yunshenBlog.github.io/js/utils.js"></script><script src="/yunshenBlog.github.io/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>
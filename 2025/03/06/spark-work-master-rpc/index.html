<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>spark在standalone模式下，worker与master的rpc通信流程 | 只在此山中，云深不知处</title><meta name="author" content="nrliangxy"><meta name="copyright" content="nrliangxy"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="&emsp;&emsp; 背景 spark集群在standalone模式下，在集群的sbin目录下，启动start-worker.sh脚本，启动了worker端点 worker端点启动后，读取配置后，在spark的rpc通信框架里面注册rpc端点，和master节点进行rpc通信并进行心跳交互 本文就是要详细探讨一下work节点是如何与master节点进行rpc通信  流程梳理1.使用start-">
<meta property="og:type" content="article">
<meta property="og:title" content="spark在standalone模式下，worker与master的rpc通信流程">
<meta property="og:url" content="https://nrliangxy.github.io/yunshenBlog.github.io/2025/03/06/spark-work-master-rpc/index.html">
<meta property="og:site_name" content="只在此山中，云深不知处">
<meta property="og:description" content="&emsp;&emsp; 背景 spark集群在standalone模式下，在集群的sbin目录下，启动start-worker.sh脚本，启动了worker端点 worker端点启动后，读取配置后，在spark的rpc通信框架里面注册rpc端点，和master节点进行rpc通信并进行心跳交互 本文就是要详细探讨一下work节点是如何与master节点进行rpc通信  流程梳理1.使用start-">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://nrliangxy.github.io/yunshenBlog.github.io/img/butterfly-icon.png">
<meta property="article:published_time" content="2025-03-06T01:13:14.000Z">
<meta property="article:modified_time" content="2025-03-10T05:36:05.486Z">
<meta property="article:author" content="nrliangxy">
<meta property="article:tag" content="spark 3.3.0">
<meta property="article:tag" content="standalone">
<meta property="article:tag" content="rpc">
<meta property="article:tag" content="worker">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://nrliangxy.github.io/yunshenBlog.github.io/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "spark在standalone模式下，worker与master的rpc通信流程",
  "url": "https://nrliangxy.github.io/yunshenBlog.github.io/2025/03/06/spark-work-master-rpc/",
  "image": "https://nrliangxy.github.io/yunshenBlog.github.io/img/butterfly-icon.png",
  "datePublished": "2025-03-06T01:13:14.000Z",
  "dateModified": "2025-03-10T05:36:05.486Z",
  "author": [
    {
      "@type": "Person",
      "name": "nrliangxy",
      "url": "https://nrliangxy.github.io/yunshenBlog.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/yunshenBlog.github.io/img/favicon.png"><link rel="canonical" href="https://nrliangxy.github.io/yunshenBlog.github.io/2025/03/06/spark-work-master-rpc/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/yunshenBlog.github.io/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/yunshenBlog.github.io/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'spark在standalone模式下，worker与master的rpc通信流程',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/yunshenBlog.github.io/"><span class="site-name">只在此山中，云深不知处</span></a><a class="nav-page-title" href="/yunshenBlog.github.io/"><span class="site-name">spark在standalone模式下，worker与master的rpc通信流程</span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">spark在standalone模式下，worker与master的rpc通信流程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2025-03-06T01:13:14.000Z" title="Created 2025-03-06 09:13:14">2025-03-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-03-10T05:36:05.486Z" title="Updated 2025-03-10 13:36:05">2025-03-10</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/yunshenBlog.github.io/categories/%E6%8A%80%E6%9C%AF/">技术</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/yunshenBlog.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%A4%A7%E6%95%B0%E6%8D%AE%E8%AE%A1%E7%AE%97/">大数据计算</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/yunshenBlog.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%A4%A7%E6%95%B0%E6%8D%AE%E8%AE%A1%E7%AE%97/%E6%89%B9%E5%A4%84%E7%90%86/">批处理</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/yunshenBlog.github.io/categories/%E6%8A%80%E6%9C%AF/%E5%A4%A7%E6%95%B0%E6%8D%AE%E8%AE%A1%E7%AE%97/%E6%89%B9%E5%A4%84%E7%90%86/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>&emsp;&emsp;</p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><ul>
<li>spark集群在standalone模式下，在集群的sbin目录下，启动start-worker.sh脚本，启动了worker端点</li>
<li>worker端点启动后，读取配置后，在spark的rpc通信框架里面注册rpc端点，和master节点进行rpc通信并进行心跳交互</li>
<li>本文就是要详细探讨一下work节点是如何与master节点进行rpc通信</li>
</ul>
<h2 id="流程梳理"><a href="#流程梳理" class="headerlink" title="流程梳理"></a>流程梳理</h2><h3 id="1-使用start-worker-sh脚本启动worker节点"><a href="#1-使用start-worker-sh脚本启动worker节点" class="headerlink" title="1.使用start-worker.sh脚本启动worker节点"></a>1.使用start-worker.sh脚本启动worker节点</h3><h4 id="1-在客户端提交命令样例"><a href="#1-在客户端提交命令样例" class="headerlink" title="(1) 在客户端提交命令样例"></a>(1) 在客户端提交命令样例</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash start-worker.sh</span><br></pre></td></tr></table></figure>

<h4 id="2-代码"><a href="#2-代码" class="headerlink" title="(2) 代码"></a>(2) 代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">  def main(argStrings: Array[String]): Unit = &#123;</span><br><span class="line">//    设置一个默认的未捕获异常处理器 SparkUncaughtExceptionHandler。</span><br><span class="line">//    exitOnUncaughtException = false 表示当发生未捕获异常时，不会直接退出 JVM，而是记录日志并继续运行。</span><br><span class="line">    Thread.setDefaultUncaughtExceptionHandler(new SparkUncaughtExceptionHandler(</span><br><span class="line">      exitOnUncaughtException = false))</span><br><span class="line">//    调用 Utils.initDaemon 方法，初始化守护线程的日志配置。</span><br><span class="line">    Utils.initDaemon(log)</span><br><span class="line">//    创建一个 SparkConf 对象，用于加载和存储 Spark 的配置参数。</span><br><span class="line">    val conf = new SparkConf</span><br><span class="line">//    使用 WorkerArguments 类解析命令行参数 argStrings，并将解析后的参数存储到 args 中。</span><br><span class="line">//    WorkerArguments 是一个辅助类，用于解析 Worker 的启动参数（如主机名、端口号、核心数、内存等）。</span><br><span class="line">    val args = new WorkerArguments(argStrings, conf)</span><br><span class="line">    /**</span><br><span class="line">     * 调用 startRpcEnvAndEndpoint 方法，启动 Worker 的 RPC 环境并注册 Worker 端点。</span><br><span class="line">     * 参数说明：</span><br><span class="line">     * args.host：Worker 的主机名。</span><br><span class="line">     * args.port：Worker 的 RPC 端口。</span><br><span class="line">     * args.webUiPort：Worker 的 Web UI 端口。</span><br><span class="line">     * args.cores：Worker 可用的 CPU 核心数。</span><br><span class="line">     * args.memory：Worker 可用的内存大小。</span><br><span class="line">     * args.masters：Master 的地址列表（Worker 需要向这些 Master 注册）。</span><br><span class="line">     * args.workDir：Worker 的工作目录。</span><br><span class="line">     * conf：Spark 配置对象。</span><br><span class="line">     * resourceFileOpt：Worker 的资源文件路径（可选）。</span><br><span class="line">     */</span><br><span class="line">    val rpcEnv = startRpcEnvAndEndpoint(args.host, args.port, args.webUiPort, args.cores,</span><br><span class="line">      args.memory, args.masters, args.workDir, conf = conf,</span><br><span class="line">      resourceFileOpt = conf.get(SPARK_WORKER_RESOURCE_FILE))</span><br><span class="line">    // With external shuffle service enabled, if we request to launch multiple workers on one host,</span><br><span class="line">    // we can only successfully launch the first worker and the rest fails, because with the port</span><br><span class="line">    // bound, we may launch no more than one external shuffle service on each host.</span><br><span class="line">    // When this happens, we should give explicit reason of failure instead of fail silently. For</span><br><span class="line">    // more detail see SPARK-20989.</span><br><span class="line">//    检查是否启用了外部 Shuffle 服务（spark.shuffle.service.enabled）。</span><br><span class="line">//    获取环境变量 SPARK_WORKER_INSTANCES 的值，表示在同一主机上启动的 Worker 实例数。</span><br><span class="line">//    如果启用了外部 Shuffle 服务，并且尝试在同一主机上启动多个 Worker 实例，则抛出异常。</span><br><span class="line">//    原因是每个主机上只能启动一个外部 Shuffle 服务，多个 Worker 实例会导致端口冲突。</span><br><span class="line">    val externalShuffleServiceEnabled = conf.get(config.SHUFFLE_SERVICE_ENABLED)</span><br><span class="line">    val sparkWorkerInstances = scala.sys.env.getOrElse(&quot;SPARK_WORKER_INSTANCES&quot;, &quot;1&quot;).toInt</span><br><span class="line">    require(externalShuffleServiceEnabled == false || sparkWorkerInstances &lt;= 1,</span><br><span class="line">      &quot;Starting multiple workers on one host is failed because we may launch no more than one &quot; +</span><br><span class="line">        &quot;external shuffle service on each host, please set spark.shuffle.service.enabled to &quot; +</span><br><span class="line">        &quot;false or set SPARK_WORKER_INSTANCES to 1 to resolve the conflict.&quot;)</span><br><span class="line">//    调用 rpcEnv.awaitTermination()，使 Worker 的主线程进入等待状态，直到 RPC 环境终止。</span><br><span class="line">//    这是为了让 Worker 持续运行，直到显式关闭或发生异常。</span><br><span class="line">    rpcEnv.awaitTermination()</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-代码解析"><a href="#3-代码解析" class="headerlink" title="(3) 代码解析"></a>(3) 代码解析</h4><ul>
<li>源代码路径：org.apache.spark.deploy.worker.Worker#main</li>
<li>获取spark的相关配置，启动worker的rpc环境并且注册worker端点</li>
<li>注册rpc的worker端点后，会自动启动onStart()函数</li>
</ul>
<h3 id="2-通过自启动onStart-方法，worker节点开始与master节点创建rpc连接"><a href="#2-通过自启动onStart-方法，worker节点开始与master节点创建rpc连接" class="headerlink" title="2.通过自启动onStart()方法，worker节点开始与master节点创建rpc连接"></a>2.通过自启动onStart()方法，worker节点开始与master节点创建rpc连接</h3><h4 id="1-代码"><a href="#1-代码" class="headerlink" title="(1) 代码"></a>(1) 代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">  override def onStart(): Unit = &#123;</span><br><span class="line">//    assert(!registered): 确保 Worker 尚未注册到 Master 节点。</span><br><span class="line">//    registered: 是一个布尔变量，表示 Worker 是否已经注册到 Master。</span><br><span class="line">    assert(!registered)</span><br><span class="line">//    Worker 的主机名（host）和端口号（port）。</span><br><span class="line">//    Worker 的核心数（cores）和内存大小（memory）</span><br><span class="line">    logInfo(&quot;Starting Spark worker %s:%d with %d cores, %s RAM&quot;.format(</span><br><span class="line">      host, port, cores, Utils.megabytesToString(memory)))</span><br><span class="line">//    Spark 版本（org.apache.spark.SPARK_VERSION）</span><br><span class="line">    logInfo(s&quot;Running Spark version $&#123;org.apache.spark.SPARK_VERSION&#125;&quot;)</span><br><span class="line">//    Spark 的安装目录（sparkHome）</span><br><span class="line">    logInfo(&quot;Spark home: &quot; + sparkHome)</span><br><span class="line">//    createWorkDir(): 创建 Worker 的工作目录，用于存储临时文件和日志。</span><br><span class="line">//    工作目录的路径通常由 spark.worker.dir 配置项指定。</span><br><span class="line">    createWorkDir()</span><br><span class="line">//    startExternalShuffleService(): 启动外部 Shuffle 服务（如果配置了 spark.shuffle.service.enabled）。</span><br><span class="line">//    外部 Shuffle 服务用于在 Executor 之间传输 Shuffle 数据，减少 Executor 的负担。</span><br><span class="line">    startExternalShuffleService()</span><br><span class="line">//    setupWorkerResources(): 设置 Worker 的资源（如 CPU 和内存），并检查资源是否满足要求。</span><br><span class="line">    setupWorkerResources()</span><br><span class="line">//    new WorkerWebUI(this, workDir, webUiPort): 创建 Worker 的 Web UI 实例。</span><br><span class="line">    webUi = new WorkerWebUI(this, workDir, webUiPort)</span><br><span class="line">//    webUi.bind(): 绑定 Web UI 到指定的端口，启动 Web 服务。</span><br><span class="line">    webUi.bind()</span><br><span class="line">//    workerWebUiUrl: 设置 Worker Web UI 的访问 URL，格式为 http://&lt;public-address&gt;:&lt;port&gt;。</span><br><span class="line">    workerWebUiUrl = s&quot;$&#123;webUi.scheme&#125;$publicAddress:$&#123;webUi.boundPort&#125;&quot;</span><br><span class="line">//    registerWithMaster(): 向 Master 节点发送注册请求，将 Worker 注册到集群中。</span><br><span class="line">    registerWithMaster()</span><br><span class="line">//    metricsSystem.registerSource(workerSource): 注册 Worker 的 Metrics 数据源，用于收集和上报 Worker 的运行指标。</span><br><span class="line">    metricsSystem.registerSource(workerSource)</span><br><span class="line">//    metricsSystem.start(): 启动 Metrics 系统。</span><br><span class="line">    metricsSystem.start()</span><br><span class="line">    // Attach the worker metrics servlet handler to the web ui after the metrics system is started.</span><br><span class="line">//    metricsSystem.getServletHandlers: 获取 Metrics 系统的 Servlet 处理器。</span><br><span class="line">//    webUi.attachHandler: 将 Metrics Servlet 绑定到 Worker 的 Web UI，以便通过 Web UI 查看 Metrics 数据。</span><br><span class="line">    metricsSystem.getServletHandlers.foreach(webUi.attachHandler)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">  private def registerWithMaster(): Unit = &#123;</span><br><span class="line">    // onDisconnected may be triggered multiple times, so don&#x27;t attempt registration</span><br><span class="line">    // if there are outstanding registration attempts scheduled.</span><br><span class="line">//    registrationRetryTimer: 是一个 Option[ScheduledFuture[_]]，表示当前的注册任务。</span><br><span class="line">    registrationRetryTimer match &#123;</span><br><span class="line">//    None: 如果没有注册任务，则执行注册逻辑。</span><br><span class="line">      case None =&gt;</span><br><span class="line">//        将 registered 标志设置为 false，表示尚未注册成功。</span><br><span class="line">        registered = false</span><br><span class="line">//        调用 tryRegisterAllMasters()，尝试向所有已知的 Master 节点注册。</span><br><span class="line">        registerMasterFutures = tryRegisterAllMasters()</span><br><span class="line">//        重置连接尝试计数器。</span><br><span class="line">        connectionAttemptCount = 0</span><br><span class="line">//        使用 forwardMessageScheduler.scheduleAtFixedRate() 创建一个定时任务，定期发送 ReregisterWithMaster 消息。</span><br><span class="line">        registrationRetryTimer = Some(forwardMessageScheduler.scheduleAtFixedRate(</span><br><span class="line">//          捕获并记录非致命异常。向 Master 自己发送 ReregisterWithMaster 消息。</span><br><span class="line">          () =&gt; Utils.tryLogNonFatalError &#123; Option(self).foreach(_.send(ReregisterWithMaster)) &#125;,</span><br><span class="line">//          INITIAL_REGISTRATION_RETRY_INTERVAL_SECONDS: 定时任务的初始延迟时间和执行间隔时间（单位：秒）</span><br><span class="line">//          TimeUnit.SECONDS: 时间单位，表示秒。</span><br><span class="line">          INITIAL_REGISTRATION_RETRY_INTERVAL_SECONDS,</span><br><span class="line">          INITIAL_REGISTRATION_RETRY_INTERVAL_SECONDS,</span><br><span class="line">          TimeUnit.SECONDS))</span><br><span class="line">//        Some(_): 如果已有注册任务，则跳过，避免重复注册。</span><br><span class="line">      case Some(_) =&gt;</span><br><span class="line">        logInfo(&quot;Not spawning another attempt to register with the master, since there is an&quot; +</span><br><span class="line">          &quot; attempt scheduled already.&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">  /**</span><br><span class="line">   * 这是一个私有方法，返回一个 Array[JFuture[_]]，表示向所有 Master 注册的异步任务的结果。</span><br><span class="line">   * JFuture[_] 是 Java 的 Future 类型，表示异步任务的结果。</span><br><span class="line">   * @return 返回一个 Array[JFuture[_]]，包含所有向 Master 注册的异步任务的结果。</span><br><span class="line">   */</span><br><span class="line">  private def tryRegisterAllMasters(): Array[JFuture[_]] = &#123;</span><br><span class="line">//    masterRpcAddresses 是一个包含所有配置的 Master RPC 地址的集合。样例：masterRpcAddresses = [&quot;master1:7077&quot;, &quot;master2:7077&quot;, &quot;master3:7077&quot;]</span><br><span class="line">//    使用 map 方法遍历每个 Master 地址，并为每个地址创建一个注册任务。</span><br><span class="line">    masterRpcAddresses.map &#123; masterAddress =&gt;</span><br><span class="line">//      使用 registerMasterThreadPool（一个线程池）提交一个 Runnable 任务。每个任务会尝试向一个 Master 注册。</span><br><span class="line">      registerMasterThreadPool.submit(new Runnable &#123;</span><br><span class="line">        override def run(): Unit = &#123;</span><br><span class="line">          try &#123;</span><br><span class="line">//            记录日志，显示正在连接哪个 Master。</span><br><span class="line">            logInfo(&quot;Connecting to master &quot; + masterAddress + &quot;...&quot;)</span><br><span class="line">//          使用 rpcEnv.setupEndpointRef 方法，根据 Master 的地址（masterAddress）和 Master 的 RPC 端点名称（Master.ENDPOINT_NAME）</span><br><span class="line">//          ，获取 Master 的 RPC 端点引用（masterEndpoint）。</span><br><span class="line">            val masterEndpoint = rpcEnv.setupEndpointRef(masterAddress, Master.ENDPOINT_NAME)</span><br><span class="line">//            调用 sendRegisterMessageToMaster 方法，向 Master 发送注册消息。注册消息的内容通常包括 Worker 的基本信息</span><br><span class="line">            //            （如 Worker ID、主机名、端口、资源等）。</span><br><span class="line">            sendRegisterMessageToMaster(masterEndpoint)</span><br><span class="line">          &#125; catch &#123;</span><br><span class="line">            case ie: InterruptedException =&gt; // Cancelled</span><br><span class="line">            case NonFatal(e) =&gt; logWarning(s&quot;Failed to connect to master $masterAddress&quot;, e)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private def sendRegisterMessageToMaster(masterEndpoint: RpcEndpointRef): Unit = &#123;</span><br><span class="line">  masterEndpoint.send(RegisterWorker(</span><br><span class="line">    workerId,</span><br><span class="line">    host,</span><br><span class="line">    port,</span><br><span class="line">    self,</span><br><span class="line">    cores,</span><br><span class="line">    memory,</span><br><span class="line">    workerWebUiUrl,</span><br><span class="line">    masterEndpoint.address,</span><br><span class="line">    resources))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-代码解析"><a href="#2-代码解析" class="headerlink" title="(2) 代码解析"></a>(2) 代码解析</h4><ul>
<li>源代码路径：org.apache.spark.deploy.worker.Worker#onStart</li>
<li>在onStart()函数里面，先创建该worker的工作目录，检查资源，创建Web UI实例</li>
<li>通过registerWithMaster()开始尝试向所有已知的master节点注册</li>
<li>接着在registerWithMaster()函数里面，调用tryRegisterAllMasters()函数</li>
<li>在tryRegisterAllMasters()函数里面，使用 rpcEnv.setupEndpointRef 方法，根据 Master 的地址（masterAddress）和 Master 的 RPC 端点名称（Master.ENDPOINT_NAME），获取 Master 的 RPC 端点引用（masterEndpoint）</li>
<li>通过sendRegisterMessageToMaster函数，向Master发送注册信息，注册信息包含Worker的基本信息（如 Worker ID、主机名、端口、资源等）</li>
</ul>
<h3 id="3-Master节点接收Worker发送的注册信息，触发了Master的receive函数"><a href="#3-Master节点接收Worker发送的注册信息，触发了Master的receive函数" class="headerlink" title="3.Master节点接收Worker发送的注册信息，触发了Master的receive函数"></a>3.Master节点接收Worker发送的注册信息，触发了Master的receive函数</h3><h4 id="1-代码-1"><a href="#1-代码-1" class="headerlink" title="(1) 代码"></a>(1) 代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">    /**</span><br><span class="line">     * RegisterWorker 消息包含以下字段：</span><br><span class="line">     * id：Worker 的唯一标识符</span><br><span class="line">     * workerHost：Worker 的主机名</span><br><span class="line">     * workerPort：Worker 的端口号</span><br><span class="line">     * workerRef：Worker 的 RPC 端点引用</span><br><span class="line">     * cores：Worker 提供的 CPU 核心数</span><br><span class="line">     * memory：Worker 提供的内存大小</span><br><span class="line">     * workerWebUiUrl：Worker 的 Web UI 地址</span><br><span class="line">     * masterAddress：Worker 连接的 Master 地址</span><br><span class="line">     * resources：Worker 提供的资源信息（例如 GPU 等）</span><br><span class="line">     */</span><br><span class="line">    case RegisterWorker(</span><br><span class="line">      id, workerHost, workerPort, workerRef, cores, memory, workerWebUiUrl,</span><br><span class="line">      masterAddress, resources) =&gt;</span><br><span class="line">//      记录日志，显示正在注册的 Worker 的详细信息，包括主机名、端口、CPU 核心数和内存大小。</span><br><span class="line">      logInfo(&quot;Registering worker %s:%d with %d cores, %s RAM&quot;.format(</span><br><span class="line">        workerHost, workerPort, cores, Utils.megabytesToString(memory)))</span><br><span class="line">//      如果 Master 当前处于 STANDBY 状态（即备用状态），表示它不能处理 Worker 的注册请求。</span><br><span class="line">      if (state == RecoveryState.STANDBY) &#123;</span><br><span class="line">//      向 Worker 发送 MasterInStandby 消息，通知 Worker 当前 Master 是备用节点，无法注册。</span><br><span class="line">        workerRef.send(MasterInStandby)</span><br><span class="line">//        如果 idToWorker 中已经包含该 Worker 的 ID，表示该 Worker 已经注册过。</span><br><span class="line">      &#125; else if (idToWorker.contains(id)) &#123;</span><br><span class="line">//        向 Worker 发送 RegisteredWorker 消息，通知 Worker 注册成功，但这是一个重复注册（duplicate = true）</span><br><span class="line">        workerRef.send(RegisteredWorker(self, masterWebUiUrl, masterAddress, true))</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">//        如果 Worker 是一个新节点（未注册过），则继续处理注册逻辑。</span><br><span class="line">//        将 Worker 提供的资源信息（resources）转换为 WorkerResourceInfo 对象。</span><br><span class="line">        val workerResources = resources.map(r =&gt; r._1 -&gt; WorkerResourceInfo(r._1, r._2.addresses))</span><br><span class="line">//        创建一个 WorkerInfo 对象，表示该 Worker 的详细信息。</span><br><span class="line">        val worker = new WorkerInfo(id, workerHost, workerPort, cores, memory,</span><br><span class="line">          workerRef, workerWebUiUrl, workerResources)</span><br><span class="line">        if (registerWorker(worker)) &#123;</span><br><span class="line">//          调用 persistenceEngine.addWorker(worker)，将 Worker 信息持久化（用于故障恢复）。</span><br><span class="line">          persistenceEngine.addWorker(worker)</span><br><span class="line">//          向 Worker 发送 RegisteredWorker 消息，通知 Worker 注册成功（duplicate = false）。</span><br><span class="line">          workerRef.send(RegisteredWorker(self, masterWebUiUrl, masterAddress, false))</span><br><span class="line">//          调用 schedule() 方法，触发资源调度逻辑（例如为等待的应用程序分配资源）。</span><br><span class="line">          schedule()</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          val workerAddress = worker.endpoint.address</span><br><span class="line">//          如果注册失败（例如 Worker 地址冲突），记录警告日志。</span><br><span class="line">          logWarning(&quot;Worker registration failed. Attempted to re-register worker at same &quot; +</span><br><span class="line">            &quot;address: &quot; + workerAddress)</span><br><span class="line">//          向 Worker 发送 RegisterWorkerFailed 消息，通知 Worker 注册失败，并提供失败原因。</span><br><span class="line">          workerRef.send(RegisterWorkerFailed(&quot;Attempted to re-register worker at same address: &quot;</span><br><span class="line">            + workerAddress))</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-代码解析-1"><a href="#2-代码解析-1" class="headerlink" title="(2) 代码解析"></a>(2) 代码解析</h4><ul>
<li>源代码路径：org.apache.spark.deploy.master.Master#receive</li>
<li>接收到Worker节点注册的rpc信息后，如果该Master节点是STANDBY状态，就通知注册的Worker节点，不能进行注册</li>
<li>如果注册的worker ID已经在idToWorker存在了，表示该Worker已经注册过。同时向 Worker 发送 RegisteredWorker 消息，通知 Worker 注册成功，但这是一个重复注册（duplicate &#x3D; true）</li>
<li>如果该Worker是一个新节点，未注册过。先在Master节点上进行注册，如果注册成功，就将Worker 信息持久化（用于故障恢复），同时向 Worker 发送 RegisteredWorker 消息，通知 Worker 注册成功（duplicate &#x3D; false）</li>
</ul>
<h3 id="4-Worker节点接收Master节点rpc反馈，更新状态registered为true"><a href="#4-Worker节点接收Master节点rpc反馈，更新状态registered为true" class="headerlink" title="4.Worker节点接收Master节点rpc反馈，更新状态registered为true"></a>4.Worker节点接收Master节点rpc反馈，更新状态registered为true</h3><h4 id="1-代码-2"><a href="#1-代码-2" class="headerlink" title="(1) 代码"></a>(1) 代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">  private def handleRegisterResponse(msg: RegisterWorkerResponse): Unit = synchronized &#123;</span><br><span class="line">    msg match &#123;</span><br><span class="line">      /**</span><br><span class="line">       * masterRef：Master 的 RPC 端点引用。</span><br><span class="line">       * masterWebUiUrl：Master 的 Web UI 地址。</span><br><span class="line">       * masterAddress：Master 的地址。</span><br><span class="line">       * duplicate：是否是一个重复注册（布尔值）。</span><br><span class="line">       */</span><br><span class="line">      case RegisteredWorker(masterRef, masterWebUiUrl, masterAddress, duplicate) =&gt;</span><br><span class="line">//        根据配置 preferConfiguredMasterAddress 决定使用哪个 Master 地址：</span><br><span class="line">//        如果 preferConfiguredMasterAddress 为 true，使用配置的 Master 地址（masterAddress.toSparkURL）。</span><br><span class="line">//        否则，使用 Master 的 RPC 端点地址（masterRef.address.toSparkURL）。</span><br><span class="line">        val preferredMasterAddress = if (preferConfiguredMasterAddress) &#123;</span><br><span class="line">          masterAddress.toSparkURL</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          masterRef.address.toSparkURL</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // there&#x27;re corner cases which we could hardly avoid duplicate worker registration,</span><br><span class="line">        // e.g. Master disconnect(maybe due to network drop) and recover immediately, see</span><br><span class="line">        // SPARK-23191 for more details.</span><br><span class="line">//        如果 duplicate 为 true，表示这是一个重复注册。</span><br><span class="line">        if (duplicate) &#123;</span><br><span class="line">//          记录警告日志，显示在哪个 Master 上发生了重复注册。</span><br><span class="line">          logWarning(s&quot;Duplicate registration at master $preferredMasterAddress&quot;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        logInfo(s&quot;Successfully registered with master $preferredMasterAddress&quot;)</span><br><span class="line">//        将 registered 标志设置为 true，表示 Worker 已成功注册。</span><br><span class="line">        registered = true</span><br><span class="line">//        调用 changeMaster 方法，更新 Worker 的 Master 信息（包括 RPC 引用、Web UI 地址和 Master 地址）。</span><br><span class="line">        changeMaster(masterRef, masterWebUiUrl, masterAddress)</span><br><span class="line">//        forwardMessageScheduler.scheduleAtFixedRate 是一个定时任务。它会按照指定的时间间隔周期性地执行某个操作</span><br><span class="line">//        周期性执行：这个任务会每隔 HEARTBEAT_MILLIS 毫秒执行一次，发送 SendHeartbeat 消息。</span><br><span class="line">//        持续时间：只要 Worker 和 Master 之间的连接存在，并且 Worker 没有停止或崩溃，这个定时任务就会一直运行下去。</span><br><span class="line">//        目的：心跳机制的主要目的是让 Master 知道 Worker 仍然存活，并且能够及时检测到 Worker 的故障。如果 Worker 停止发送心跳，</span><br><span class="line">//        Master 会认为该 Worker 已经失效，并将其从集群中移除。</span><br><span class="line">//        使用 forwardMessageScheduler 启动一个定时任务，定期向 Worker 自身发送 SendHeartbeat 消息。</span><br><span class="line">        /**</span><br><span class="line">         * 定时任务的参数：</span><br><span class="line">         * 初始延迟：0，表示立即执行。</span><br><span class="line">         * 间隔时间：HEARTBEAT_MILLIS 毫秒，表示心跳的发送频率。</span><br><span class="line">         * 时间单位：TimeUnit.MILLISECONDS，表示时间单位为毫秒。</span><br><span class="line">         */</span><br><span class="line">        forwardMessageScheduler.scheduleAtFixedRate(</span><br><span class="line">          () =&gt; Utils.tryLogNonFatalError &#123; self.send(SendHeartbeat) &#125;,</span><br><span class="line">          0, HEARTBEAT_MILLIS, TimeUnit.MILLISECONDS)</span><br><span class="line">        if (CLEANUP_ENABLED) &#123;</span><br><span class="line">//          定期删除 Worker 工作目录中的旧应用程序文件，避免磁盘空间被占满。</span><br><span class="line">          logInfo(</span><br><span class="line">            s&quot;Worker cleanup enabled; old application directories will be deleted in: $workDir&quot;)</span><br><span class="line">          forwardMessageScheduler.scheduleAtFixedRate(</span><br><span class="line">            () =&gt; Utils.tryLogNonFatalError &#123; self.send(WorkDirCleanup) &#125;,</span><br><span class="line">            CLEANUP_INTERVAL_MILLIS, CLEANUP_INTERVAL_MILLIS, TimeUnit.MILLISECONDS)</span><br><span class="line">        &#125;</span><br><span class="line">//        获取 Worker 上所有 Executor 的状态信息，并转换为 ExecutorDescription 对象。</span><br><span class="line">        /**</span><br><span class="line">         * 向 Master 发送 WorkerLatestState 消息，包含以下信息：</span><br><span class="line">         * workerId：Worker 的唯一标识符。</span><br><span class="line">         * execs.toList：Worker 上所有 Executor 的状态列表。</span><br><span class="line">         * drivers.keys.toSeq：Worker 上所有 Driver 的 ID 列表。</span><br><span class="line">         * 作用：让 Master 知道 Worker 的当前状态，包括 Executor 和 Driver 的信息。</span><br><span class="line">         */</span><br><span class="line">        val execs = executors.values.map &#123; e =&gt;</span><br><span class="line">          new ExecutorDescription(e.appId, e.execId, e.cores, e.state)</span><br><span class="line">        &#125;</span><br><span class="line">        masterRef.send(WorkerLatestState(workerId, execs.toList, drivers.keys.toSeq))</span><br><span class="line"></span><br><span class="line">      case RegisterWorkerFailed(message) =&gt;</span><br><span class="line">        if (!registered) &#123;</span><br><span class="line">          logError(&quot;Worker registration failed: &quot; + message)</span><br><span class="line">          System.exit(1)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      case MasterInStandby =&gt;</span><br><span class="line">        // Ignore. Master not yet ready.</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-代码解析-2"><a href="#2-代码解析-2" class="headerlink" title="(2) 代码解析"></a>(2) 代码解析</h4><ul>
<li>源代码路径：org.apache.spark.deploy.worker.Worker#handleRegisterResponse</li>
<li>将 registered 标志设置为 true，表示 Worker 已成功注册</li>
<li>调用 changeMaster 方法，更新 Worker 的 Master 信息（包括 RPC 引用、Web UI 地址和 Master 地址）</li>
<li>获取 Worker 上所有 Executor 的状态信息，并转换为 ExecutorDescription 对象，让 Master 知道 Worker 的当前状态，包括 Executor 和 Driver 的信息</li>
</ul>
<h3 id="5-在registerWithMaster函数里面，尝试向所有已知的Master节点注册的时候，后面还有一个延迟的按照固定的时间间隔周期性地执行某个任务"><a href="#5-在registerWithMaster函数里面，尝试向所有已知的Master节点注册的时候，后面还有一个延迟的按照固定的时间间隔周期性地执行某个任务" class="headerlink" title="5.在registerWithMaster函数里面，尝试向所有已知的Master节点注册的时候，后面还有一个延迟的按照固定的时间间隔周期性地执行某个任务"></a>5.在registerWithMaster函数里面，尝试向所有已知的Master节点注册的时候，后面还有一个延迟的按照固定的时间间隔周期性地执行某个任务</h3><h4 id="1-代码-3"><a href="#1-代码-3" class="headerlink" title="(1) 代码"></a>(1) 代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">    private def registerWithMaster(): Unit = &#123;</span><br><span class="line">    // onDisconnected may be triggered multiple times, so don&#x27;t attempt registration</span><br><span class="line">    // if there are outstanding registration attempts scheduled.</span><br><span class="line">//    registrationRetryTimer: 是一个 Option[ScheduledFuture[_]]，表示当前的注册任务。</span><br><span class="line">    registrationRetryTimer match &#123;</span><br><span class="line">//    None: 如果没有注册任务，则执行注册逻辑。</span><br><span class="line">      case None =&gt;</span><br><span class="line">//        将 registered 标志设置为 false，表示尚未注册成功。</span><br><span class="line">        registered = false</span><br><span class="line">//        调用 tryRegisterAllMasters()，尝试向所有已知的 Master 节点注册。</span><br><span class="line">        registerMasterFutures = tryRegisterAllMasters()</span><br><span class="line">//        重置连接尝试计数器。</span><br><span class="line">        connectionAttemptCount = 0</span><br><span class="line">//        使用 forwardMessageScheduler.scheduleAtFixedRate() 创建一个定时任务，定期发送 ReregisterWithMaster 消息。</span><br><span class="line">//        将定时任务的 ScheduledFuture[_] 对象包装为 Some，并赋值给 registrationRetryTimer。</span><br><span class="line">//        registrationRetryTimer 是一个 Option[ScheduledFuture[_]]，用于存储当前的注册重试任务。</span><br><span class="line">//        在handleRegisterResponse方法中，如果 Worker 成功注册到 Master，会调用 cancelLastRegistrationRetry() 方法：这里会取消 registrationRetryTimer 中的定时任务，并将 registrationRetryTimer 设置为 None。</span><br><span class="line">        registrationRetryTimer = Some(forwardMessageScheduler.scheduleAtFixedRate(</span><br><span class="line">//          捕获并记录非致命异常。向 自己发送 ReregisterWithMaster 消息。</span><br><span class="line">//          Option(self)：将 self（Worker 自身的 RPC 端点引用）包装为 Option，避免空指针异常。</span><br><span class="line">//          foreach(_.send(ReregisterWithMaster))：如果 self 不为空，向 Worker 自身发送 ReregisterWithMaster 消息。</span><br><span class="line">    () =&gt; Utils.tryLogNonFatalError &#123; Option(self).foreach(_.send(ReregisterWithMaster)) &#125;,</span><br><span class="line">//          INITIAL_REGISTRATION_RETRY_INTERVAL_SECONDS: 定时任务的初始延迟时间和执行间隔时间（单位：秒）</span><br><span class="line">//          TimeUnit.SECONDS: 时间单位，表示秒。</span><br><span class="line">          INITIAL_REGISTRATION_RETRY_INTERVAL_SECONDS,</span><br><span class="line">          INITIAL_REGISTRATION_RETRY_INTERVAL_SECONDS,</span><br><span class="line">          TimeUnit.SECONDS))</span><br><span class="line">//        Some(_): 如果已有注册任务，则跳过，避免重复注册。</span><br><span class="line">      case Some(_) =&gt;</span><br><span class="line">        logInfo(&quot;Not spawning another attempt to register with the master, since there is an&quot; +</span><br><span class="line">          &quot; attempt scheduled already.&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-代码解析-3"><a href="#2-代码解析-3" class="headerlink" title="(2) 代码解析"></a>(2) 代码解析</h4><ul>
<li>源代码路径：org.apache.spark.deploy.worker.Worker#registerWithMaster</li>
<li>registrationRetryTimer里面延时执行一个周期性的定时调用匿名函数Option(self).foreach(_.send(ReregisterWithMaster))</li>
<li>向Worker自身发送ReregisterWithMaster消息</li>
</ul>
<h3 id="6-Worker节点接收自身发送的ReregisterWithMaster消息后，处理逻辑"><a href="#6-Worker节点接收自身发送的ReregisterWithMaster消息后，处理逻辑" class="headerlink" title="6.Worker节点接收自身发送的ReregisterWithMaster消息后，处理逻辑"></a>6.Worker节点接收自身发送的ReregisterWithMaster消息后，处理逻辑</h3><h4 id="1-代码-4"><a href="#1-代码-4" class="headerlink" title="(1) 代码"></a>(1) 代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">case ReregisterWithMaster =&gt;</span><br><span class="line">  reregisterWithMaster()</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">  /**</span><br><span class="line">   * Re-register with the master because a network failure or a master failure has occurred.</span><br><span class="line">   * If the re-registration attempt threshold is exceeded, the worker exits with error.</span><br><span class="line">   * Note that for thread-safety this should only be called from the rpcEndpoint.</span><br><span class="line">   */</span><br><span class="line">  private def reregisterWithMaster(): Unit = &#123;</span><br><span class="line">    Utils.tryOrExit &#123;</span><br><span class="line">      connectionAttemptCount += 1</span><br><span class="line">//      如果已经完成注册，就取消所有正在进行的注册重试任务。</span><br><span class="line">      if (registered) &#123;</span><br><span class="line">        cancelLastRegistrationRetry()</span><br><span class="line">      &#125; else if (connectionAttemptCount &lt;= TOTAL_REGISTRATION_RETRIES) &#123;</span><br><span class="line">        logInfo(s&quot;Retrying connection to master (attempt # $connectionAttemptCount)&quot;)</span><br><span class="line">        /**</span><br><span class="line">         * Re-register with the active master this worker has been communicating with. If there</span><br><span class="line">         * is none, then it means this worker is still bootstrapping and hasn&#x27;t established a</span><br><span class="line">         * connection with a master yet, in which case we should re-register with all masters.</span><br><span class="line">         *</span><br><span class="line">         * It is important to re-register only with the active master during failures. Otherwise,</span><br><span class="line">         * if the worker unconditionally attempts to re-register with all masters, the following</span><br><span class="line">         * race condition may arise and cause a &quot;duplicate worker&quot; error detailed in SPARK-4592:</span><br><span class="line">         *</span><br><span class="line">         *   (1) Master A fails and Worker attempts to reconnect to all masters</span><br><span class="line">         *   (2) Master B takes over and notifies Worker</span><br><span class="line">         *   (3) Worker responds by registering with Master B</span><br><span class="line">         *   (4) Meanwhile, Worker&#x27;s previous reconnection attempt reaches Master B,</span><br><span class="line">         *       causing the same Worker to register with Master B twice</span><br><span class="line">         *</span><br><span class="line">         * Instead, if we only register with the known active master, we can assume that the</span><br><span class="line">         * old master must have died because another master has taken over. Note that this is</span><br><span class="line">         * still not safe if the old master recovers within this interval, but this is a much</span><br><span class="line">         * less likely scenario.</span><br><span class="line">         * 重新向当前 Worker 正在通信的活跃 Master 注册。如果没有活跃的 Master，</span><br><span class="line">         * 则意味着该 Worker 仍在启动过程中，尚未与任何 Master 建立连接，</span><br><span class="line">         * 在这种情况下，我们应该向所有 Master 重新注册。</span><br><span class="line">         *</span><br><span class="line">         * 在故障期间，仅向已知的活跃 Master 重新注册是非常重要的。否则，</span><br><span class="line">         * 如果 Worker 无条件地尝试向所有 Master 重新注册，可能会引发以下竞态条件，</span><br><span class="line">         * 并导致 SPARK-4592 中详细描述的“重复 Worker”错误：</span><br><span class="line">         *</span><br><span class="line">         * (1) Master A 故障，Worker 尝试重新连接所有 Master。</span><br><span class="line">         * (2) Master B 接管并通知 Worker。</span><br><span class="line">         * (3) Worker 响应并向 Master B 注册。</span><br><span class="line">         * (4) 与此同时，Worker 之前的重新连接尝试到达 Master B，</span><br><span class="line">         * 导致同一个 Worker 向 Master B 注册两次。</span><br><span class="line">         *</span><br><span class="line">         * 相反，如果我们仅向已知的活跃 Master 注册，我们可以假设旧的 Master 已经失效，</span><br><span class="line">         * 因为另一个 Master 已经接管。需要注意的是，如果旧的 Master 在此间隔内恢复，</span><br><span class="line">         * 这种方法仍然不安全，但这种情况发生的可能性要小得多。</span><br><span class="line">         */</span><br><span class="line">        master match &#123;</span><br><span class="line">          case Some(masterRef) =&gt;</span><br><span class="line">            // registered == false &amp;&amp; master != None means we lost the connection to master, so</span><br><span class="line">            // masterRef cannot be used and we need to recreate it again. Note: we must not set</span><br><span class="line">            // master to None due to the above comments.</span><br><span class="line">            if (registerMasterFutures != null) &#123;</span><br><span class="line">              registerMasterFutures.foreach(_.cancel(true))</span><br><span class="line">            &#125;</span><br><span class="line">            val masterAddress =</span><br><span class="line">              if (preferConfiguredMasterAddress) masterAddressToConnect.get else masterRef.address</span><br><span class="line">            registerMasterFutures = Array(registerMasterThreadPool.submit(new Runnable &#123;</span><br><span class="line">              override def run(): Unit = &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                  logInfo(&quot;Connecting to master &quot; + masterAddress + &quot;...&quot;)</span><br><span class="line">                  val masterEndpoint = rpcEnv.setupEndpointRef(masterAddress, Master.ENDPOINT_NAME)</span><br><span class="line">                  sendRegisterMessageToMaster(masterEndpoint)</span><br><span class="line">                &#125; catch &#123;</span><br><span class="line">                  case ie: InterruptedException =&gt; // Cancelled</span><br><span class="line">                  case NonFatal(e) =&gt; logWarning(s&quot;Failed to connect to master $masterAddress&quot;, e)</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;))</span><br><span class="line">          case None =&gt;</span><br><span class="line">            if (registerMasterFutures != null) &#123;</span><br><span class="line">              registerMasterFutures.foreach(_.cancel(true))</span><br><span class="line">            &#125;</span><br><span class="line">            // We are retrying the initial registration</span><br><span class="line">            registerMasterFutures = tryRegisterAllMasters()</span><br><span class="line">        &#125;</span><br><span class="line">        // We have exceeded the initial registration retry threshold</span><br><span class="line">        // All retries from now on should use a higher interval</span><br><span class="line">        /**</span><br><span class="line">         * 1. 动态调整重试策略</span><br><span class="line">         * 初始阶段：</span><br><span class="line">         * 在 Worker 启动或与 Master 断开连接后，初始阶段会以较短的间隔（INITIAL_REGISTRATION_RETRY_INTERVAL_SECONDS）频繁尝试注册。</span><br><span class="line">         * 这是为了尽快恢复与 Master 的连接，减少集群的不可用时间。</span><br><span class="line">         * 后续阶段：</span><br><span class="line">         * 如果初始阶段的重试次数达到 INITIAL_REGISTRATION_RETRIES，说明 Worker 在短时间内未能成功注册。</span><br><span class="line">         * 此时，Worker 切换到更长的重试间隔（PROLONGED_REGISTRATION_RETRY_INTERVAL_SECONDS），避免频繁重试对系统资源的消耗。</span><br><span class="line">         */</span><br><span class="line">//        当尝试次数达到INITIAL_REGISTRATION_RETRIES，就关闭之前的所有重试，然后使用较长频率去尝试和master创建连接</span><br><span class="line">        if (connectionAttemptCount == INITIAL_REGISTRATION_RETRIES) &#123;</span><br><span class="line">          registrationRetryTimer.foreach(_.cancel(true))</span><br><span class="line">          registrationRetryTimer = Some(</span><br><span class="line">            forwardMessageScheduler.scheduleAtFixedRate(</span><br><span class="line">              () =&gt; Utils.tryLogNonFatalError &#123; self.send(ReregisterWithMaster) &#125;,</span><br><span class="line">              PROLONGED_REGISTRATION_RETRY_INTERVAL_SECONDS,</span><br><span class="line">              PROLONGED_REGISTRATION_RETRY_INTERVAL_SECONDS,</span><br><span class="line">              TimeUnit.SECONDS))</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        logError(&quot;All masters are unresponsive! Giving up.&quot;)</span><br><span class="line">        System.exit(1)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="2-代码解析-4"><a href="#2-代码解析-4" class="headerlink" title="(2) 代码解析"></a>(2) 代码解析</h4><ul>
<li>该函数会根据registerWithMaster()函数里面的scheduleAtFixedRate定时周期性运行来尝试和master创建rpc连接，运行周期时间为INITIAL_REGISTRATION_RETRY_INTERVAL_SECONDS</li>
<li>在重试过程中，如果registered状态更新为true，就表示已经和master创建了rpc连接。调用cancelLastRegistrationRetry()函数取消所有正在尝试连接的master的任务</li>
<li>如果一直在重试，重试次数小于最大重试次数TOTAL_REGISTRATION_RETRIES：16次，registerWithMaster()函数里面的scheduleAtFixedRate会一直进行重试</li>
<li>在重试的过程中，重试次数connectionAttemptCount等于INITIAL_REGISTRATION_RETRIES：6次后，就会转为另外一个定时重试频率尝试和master进行建立rpc连接。</li>
<li>当重试次数connectionAttemptCount等于INITIAL_REGISTRATION_RETRIES后，就会取消正在重试连接的所有任务，然后再使用更长周期的PROLONGED_REGISTRATION_RETRY_INTERVAL_SECONDS的时间去尝试和master建立rpc连接。同时，connectionAttemptCount也在全局累加，直到connectionAttemptCount大于TOTAL_REGISTRATION_RETRIES：16次后，失败退出</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>Worker节点在启动后，会主动和配置过的master地址列表进行尝试建立rpc通信，如果该master为standby状态，就取消连接。如果该master为alive状态，就尝试建立rpc连接，更新registered状态为true。</li>
<li>在Worker节点与master建立连接的时候，会自动延时启动一个定时任务，该任务是在第一个连接没有成功的情况下，再次去尝试第二次连接</li>
<li>当第二次连接达到INITIAL_REGISTRATION_RETRIES：6次后，会取消之前的所有重试连接任务。然后重新开始第三次尝试连接，同时尝试连接的频率时间边长，直到重试次数达到TOTAL_REGISTRATION_RETRIES：16次后，还没有成功连接，就直接退出连接</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://nrliangxy.github.io/yunshenBlog.github.io">nrliangxy</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://nrliangxy.github.io/yunshenBlog.github.io/2025/03/06/spark-work-master-rpc/">https://nrliangxy.github.io/yunshenBlog.github.io/2025/03/06/spark-work-master-rpc/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/yunshenBlog.github.io/tags/spark-3-3-0/">spark 3.3.0</a><a class="post-meta__tags" href="/yunshenBlog.github.io/tags/standalone/">standalone</a><a class="post-meta__tags" href="/yunshenBlog.github.io/tags/rpc/">rpc</a><a class="post-meta__tags" href="/yunshenBlog.github.io/tags/worker/">worker</a></div><div class="post-share"><div class="social-share" data-image="/yunshenBlog.github.io/img/butterfly-icon.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/yunshenBlog.github.io/2025/02/25/spark-driver-master-rpc/" title="spark在standalone模式下，driver/application与master的rpc通信流程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">Previous</div><div class="info-item-2">spark在standalone模式下，driver/application与master的rpc通信流程</div></div><div class="info-2"><div class="info-item-1">&emsp;&emsp; 背景 spark集群在standalone模式下，在使用client模式下提交application的时候，driver运行在客户端机器上 如果客户端机器崩溃或者driver进程退出，application会失败 由于driver不在集群中，master无法直接管理driver的生命周期 本次只讨论在standalone模式下，使用client模式向master提交application的时候，driver和application与master的通信流程  流程梳理1.在客户端服务器上面提交application(1) 在客户端提交命令样例12345spark-submit --master spark://&lt;master-ip&gt;:&lt;master-port&gt; \  --deploy-mode client \  --class &lt;main-class&gt; \  &lt;application-jar&gt; \  &lt;application-args&gt;  (2)...</div></div></div></a><a class="pagination-related" href="/yunshenBlog.github.io/2025/03/21/zookeeper-master-select-leader/" title="spark在standalone模式下，使用zookeeper进行master选举流程剖析"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">Next</div><div class="info-item-2">spark在standalone模式下，使用zookeeper进行master选举流程剖析</div></div><div class="info-2"><div class="info-item-1">&emsp;&emsp; 背景 spark集群在standalone模式下，为了确保master的高可用性，使用zookeeper来实现对master监控和选举 如果当前leader宕机后，如何实现leader的快速选举和相关worker节点，driver节点的快速恢复 本文要详细探讨一下leader选举和恢复的详细细节  流程梳理1.首次启动spark集群的master节点，使用start-master.sh来启动master节点(1) 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566private[deploy] object Master extends Logging &#123;  val SYSTEM_NAME = &quot;sparkMaster&quot;  val ENDPOINT_NAME = &quot;Master&quot;  def...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/yunshenBlog.github.io/2025/02/25/spark-driver-master-rpc/" title="spark在standalone模式下，driver&#x2F;application与master的rpc通信流程"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-25</div><div class="info-item-2">spark在standalone模式下，driver&#x2F;application与master的rpc通信流程</div></div><div class="info-2"><div class="info-item-1">&emsp;&emsp; 背景 spark集群在standalone模式下，在使用client模式下提交application的时候，driver运行在客户端机器上 如果客户端机器崩溃或者driver进程退出，application会失败 由于driver不在集群中，master无法直接管理driver的生命周期 本次只讨论在standalone模式下，使用client模式向master提交application的时候，driver和application与master的通信流程  流程梳理1.在客户端服务器上面提交application(1) 在客户端提交命令样例12345spark-submit --master spark://&lt;master-ip&gt;:&lt;master-port&gt; \  --deploy-mode client \  --class &lt;main-class&gt; \  &lt;application-jar&gt; \  &lt;application-args&gt;  (2)...</div></div></div></a><a class="pagination-related" href="/yunshenBlog.github.io/2025/03/21/zookeeper-master-select-leader/" title="spark在standalone模式下，使用zookeeper进行master选举流程剖析"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-21</div><div class="info-item-2">spark在standalone模式下，使用zookeeper进行master选举流程剖析</div></div><div class="info-2"><div class="info-item-1">&emsp;&emsp; 背景 spark集群在standalone模式下，为了确保master的高可用性，使用zookeeper来实现对master监控和选举 如果当前leader宕机后，如何实现leader的快速选举和相关worker节点，driver节点的快速恢复 本文要详细探讨一下leader选举和恢复的详细细节  流程梳理1.首次启动spark集群的master节点，使用start-master.sh来启动master节点(1) 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566private[deploy] object Master extends Logging &#123;  val SYSTEM_NAME = &quot;sparkMaster&quot;  val ENDPOINT_NAME = &quot;Master&quot;  def...</div></div></div></a><a class="pagination-related" href="/yunshenBlog.github.io/2025/04/18/spark-master-to-executor-task/" title="spark 在 standalone 模式，Master 是如何调度和启动 Executor"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-18</div><div class="info-item-2">spark 在 standalone 模式，Master 是如何调度和启动 Executor</div></div><div class="info-2"><div class="info-item-1">&emsp;&emsp; 背景 spark集群在 standalone 模式下，Master 通过函数launchExecutor()通知 Worker 和 Driver 要启动一个新的 Executor，后续 Worker 和 Driver 端都是如何进行通信启动和执行 Executor？  流程梳理1，消息会发送到 Worker 的 endpoint，这是 Worker 接收消息的端点。通过这种方式，Master 告诉 Worker 启动一个新的 Executor 并为其分配资源（1）代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899case LaunchExecutor(masterUrl, appId, execId, appDesc,...</div></div></div></a><a class="pagination-related" href="/yunshenBlog.github.io/2025/03/28/spark-master-dispatch/" title="spark在standalone模式下，Master如何实现资源的调度和分配"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-28</div><div class="info-item-2">spark在standalone模式下，Master如何实现资源的调度和分配</div></div><div class="info-2"><div class="info-item-1">&emsp;&emsp; 背景 spark集群在 standalone 模式下，Master 通过函数schedule()来刷新资源情况，同时启动 Executor 的调度逻辑，为 Application 分配 Executor 资源  流程梳理1，调用scheduler()函数（1）代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960  /**   * Schedule the currently available resources among waiting apps. This method will be called   * every time a new app joins or resource availability changes.   * 调度集群资源，启动等待的 Driver 和 Executor。   * 核心逻辑：   * 检查 Master...</div></div></div></a><a class="pagination-related" href="/yunshenBlog.github.io/2025/02/08/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/" title="spark在standalone模式下，FIFO和FAIR调度模式的对象分析"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-08</div><div class="info-item-2">spark在standalone模式下，FIFO和FAIR调度模式的对象分析</div></div><div class="info-2"><div class="info-item-1">...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/yunshenBlog.github.io/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/yunshenBlog.github.io/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">nrliangxy</div><div class="author-info-description"></div><div class="site-data"><a href="/yunshenBlog.github.io/archives/"><div class="headline">Articles</div><div class="length-num">6</div></a><a href="/yunshenBlog.github.io/tags/"><div class="headline">Tags</div><div class="length-num">11</div></a><a href="/yunshenBlog.github.io/categories/"><div class="headline">Categories</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%83%8C%E6%99%AF"><span class="toc-number">1.</span> <span class="toc-text">背景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B%E6%A2%B3%E7%90%86"><span class="toc-number">2.</span> <span class="toc-text">流程梳理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BD%BF%E7%94%A8start-worker-sh%E8%84%9A%E6%9C%AC%E5%90%AF%E5%8A%A8worker%E8%8A%82%E7%82%B9"><span class="toc-number">2.1.</span> <span class="toc-text">1.使用start-worker.sh脚本启动worker节点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%9C%A8%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%8F%90%E4%BA%A4%E5%91%BD%E4%BB%A4%E6%A0%B7%E4%BE%8B"><span class="toc-number">2.1.1.</span> <span class="toc-text">(1) 在客户端提交命令样例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BB%A3%E7%A0%81"><span class="toc-number">2.1.2.</span> <span class="toc-text">(2) 代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="toc-number">2.1.3.</span> <span class="toc-text">(3) 代码解析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%80%9A%E8%BF%87%E8%87%AA%E5%90%AF%E5%8A%A8onStart-%E6%96%B9%E6%B3%95%EF%BC%8Cworker%E8%8A%82%E7%82%B9%E5%BC%80%E5%A7%8B%E4%B8%8Emaster%E8%8A%82%E7%82%B9%E5%88%9B%E5%BB%BArpc%E8%BF%9E%E6%8E%A5"><span class="toc-number">2.2.</span> <span class="toc-text">2.通过自启动onStart()方法，worker节点开始与master节点创建rpc连接</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BB%A3%E7%A0%81"><span class="toc-number">2.2.1.</span> <span class="toc-text">(1) 代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="toc-number">2.2.2.</span> <span class="toc-text">(2) 代码解析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Master%E8%8A%82%E7%82%B9%E6%8E%A5%E6%94%B6Worker%E5%8F%91%E9%80%81%E7%9A%84%E6%B3%A8%E5%86%8C%E4%BF%A1%E6%81%AF%EF%BC%8C%E8%A7%A6%E5%8F%91%E4%BA%86Master%E7%9A%84receive%E5%87%BD%E6%95%B0"><span class="toc-number">2.3.</span> <span class="toc-text">3.Master节点接收Worker发送的注册信息，触发了Master的receive函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BB%A3%E7%A0%81-1"><span class="toc-number">2.3.1.</span> <span class="toc-text">(1) 代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90-1"><span class="toc-number">2.3.2.</span> <span class="toc-text">(2) 代码解析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Worker%E8%8A%82%E7%82%B9%E6%8E%A5%E6%94%B6Master%E8%8A%82%E7%82%B9rpc%E5%8F%8D%E9%A6%88%EF%BC%8C%E6%9B%B4%E6%96%B0%E7%8A%B6%E6%80%81registered%E4%B8%BAtrue"><span class="toc-number">2.4.</span> <span class="toc-text">4.Worker节点接收Master节点rpc反馈，更新状态registered为true</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BB%A3%E7%A0%81-2"><span class="toc-number">2.4.1.</span> <span class="toc-text">(1) 代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90-2"><span class="toc-number">2.4.2.</span> <span class="toc-text">(2) 代码解析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%9C%A8registerWithMaster%E5%87%BD%E6%95%B0%E9%87%8C%E9%9D%A2%EF%BC%8C%E5%B0%9D%E8%AF%95%E5%90%91%E6%89%80%E6%9C%89%E5%B7%B2%E7%9F%A5%E7%9A%84Master%E8%8A%82%E7%82%B9%E6%B3%A8%E5%86%8C%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E5%90%8E%E9%9D%A2%E8%BF%98%E6%9C%89%E4%B8%80%E4%B8%AA%E5%BB%B6%E8%BF%9F%E7%9A%84%E6%8C%89%E7%85%A7%E5%9B%BA%E5%AE%9A%E7%9A%84%E6%97%B6%E9%97%B4%E9%97%B4%E9%9A%94%E5%91%A8%E6%9C%9F%E6%80%A7%E5%9C%B0%E6%89%A7%E8%A1%8C%E6%9F%90%E4%B8%AA%E4%BB%BB%E5%8A%A1"><span class="toc-number">2.5.</span> <span class="toc-text">5.在registerWithMaster函数里面，尝试向所有已知的Master节点注册的时候，后面还有一个延迟的按照固定的时间间隔周期性地执行某个任务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BB%A3%E7%A0%81-3"><span class="toc-number">2.5.1.</span> <span class="toc-text">(1) 代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90-3"><span class="toc-number">2.5.2.</span> <span class="toc-text">(2) 代码解析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-Worker%E8%8A%82%E7%82%B9%E6%8E%A5%E6%94%B6%E8%87%AA%E8%BA%AB%E5%8F%91%E9%80%81%E7%9A%84ReregisterWithMaster%E6%B6%88%E6%81%AF%E5%90%8E%EF%BC%8C%E5%A4%84%E7%90%86%E9%80%BB%E8%BE%91"><span class="toc-number">2.6.</span> <span class="toc-text">6.Worker节点接收自身发送的ReregisterWithMaster消息后，处理逻辑</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BB%A3%E7%A0%81-4"><span class="toc-number">2.6.1.</span> <span class="toc-text">(1) 代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BB%A3%E7%A0%81%E8%A7%A3%E6%9E%90-4"><span class="toc-number">2.6.2.</span> <span class="toc-text">(2) 代码解析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">3.</span> <span class="toc-text">总结</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Posts</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/yunshenBlog.github.io/2025/04/18/spark-master-to-executor-task/" title="spark 在 standalone 模式，Master 是如何调度和启动 Executor">spark 在 standalone 模式，Master 是如何调度和启动 Executor</a><time datetime="2025-04-17T22:53:11.000Z" title="Created 2025-04-18 06:53:11">2025-04-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/yunshenBlog.github.io/2025/03/28/spark-master-dispatch/" title="spark在standalone模式下，Master如何实现资源的调度和分配">spark在standalone模式下，Master如何实现资源的调度和分配</a><time datetime="2025-03-28T01:57:10.000Z" title="Created 2025-03-28 09:57:10">2025-03-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/yunshenBlog.github.io/2025/03/21/zookeeper-master-select-leader/" title="spark在standalone模式下，使用zookeeper进行master选举流程剖析">spark在standalone模式下，使用zookeeper进行master选举流程剖析</a><time datetime="2025-03-21T03:57:09.000Z" title="Created 2025-03-21 11:57:09">2025-03-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/yunshenBlog.github.io/2025/03/06/spark-work-master-rpc/" title="spark在standalone模式下，worker与master的rpc通信流程">spark在standalone模式下，worker与master的rpc通信流程</a><time datetime="2025-03-06T01:13:14.000Z" title="Created 2025-03-06 09:13:14">2025-03-06</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/yunshenBlog.github.io/2025/02/25/spark-driver-master-rpc/" title="spark在standalone模式下，driver/application与master的rpc通信流程">spark在standalone模式下，driver/application与master的rpc通信流程</a><time datetime="2025-02-25T12:27:00.000Z" title="Created 2025-02-25 20:27:00">2025-02-25</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By nrliangxy</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/yunshenBlog.github.io/js/utils.js"></script><script src="/yunshenBlog.github.io/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>